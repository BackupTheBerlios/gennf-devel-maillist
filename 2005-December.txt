From florenz at cs.tu-berlin.de  Thu Dec  1 13:54:22 2005
From: florenz at cs.tu-berlin.de (Florian Lorenzen)
Date: Thu, 1 Dec 2005 13:54:22 +0100
Subject: [gennf-devel] Commit Mails
Message-ID: <20051201125422.GB9300@caro.cs.tu-berlin.de>

Tag zusammen,

was haltet Ihr von Commit Mails?

Florian
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 185 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/gennf-devel/attachments/20051201/f6a8130f/attachment.pgp>

From hannes at mehnert.org  Thu Dec  1 23:43:53 2005
From: hannes at mehnert.org (Hannes Mehnert)
Date: Thu, 01 Dec 2005 23:43:53 +0100
Subject: [gennf-devel] Commit Mails
In-Reply-To: <20051201125422.GB9300@caro.cs.tu-berlin.de>
References: <20051201125422.GB9300@caro.cs.tu-berlin.de>
Message-ID: <438F7CA9.1030503@mehnert.org>

Hallo Florian,

Florian Lorenzen wrote:
> was haltet Ihr von Commit Mails?

eine gute Idee. Finde ich sinnvoll.

Danke fuer die Mailingliste,

hannes


From nobody at sheep.berlios.de  Fri Dec  2 11:48:22 2005
From: nobody at sheep.berlios.de (florenz)
Date: Fri, 2 Dec 2005 11:48:22 +0100
Subject: [gennf-devel] gennf F-01BFC84C7B5AA5916B1FC95B481B0DEC.lisp,NONE,1.1 F-1474E393BE5A7EE83A4D941FA7F9346D.lisp,NONE,1.1 F-14CAFC7D376F98290437724D067E63D4.lisp,NONE,1.1 F-1923CF213AD21CBF66474E7C068BFECD.lisp,NONE,1.1 F-21E77680CDA9B7DA5133627E47FA0987.lisp,NONE,1.1 F-24AFFF4D581EFC1C6EF802B4AAB5D27B.lisp,NONE,1.1 F-32A3BA955BE6E0F48ABEDF5C42137D5E.lisp,NONE,1.1 F-389E31FE3917AE1504A5DED502AE3D51.lisp,NONE,1.1 F-3C5788EDE4B0D9B8845BDDF41278246B.lisp,NONE,1.1 F-3CDB81902ABA8CED95DEEBDA8590315E.lisp,NONE,1.1 F-40CE98E89C297E85E8209004EE49D372.lisp,NONE,1.1 F-418A4A44531B20FCEB6851D533A75A04.lisp,NONE,1.1 F-4F2D9B26F5FB9FA0F66EBB82BE7E8EF1.lisp,NONE,1.1 F-4F34E424D04A8DF9D18E24CFE19D425C.lisp,NONE,1.1 F-54A44C0786853024F450D715BBB3997E.lisp,NONE,1.1 F-5B815906BE2D64E9BC2E48B76242BFF2.lisp,NONE,1.1 F-6763C87866B0E9BE56C154839D6FAB55.lisp,NONE,1.1 F-6C2D433380C1B1B204522582A4F30484.lisp,NONE,1.1 F-74915F0862B511AC9C233FDCB87DBEF8.lisp,NONE,1.1 F-7849808E8711BA9FBEB0917F33B12A79.lisp,NONE,1.1 F-8E73F07FB339A6981C69AF06C278B49A.lisp,NONE,1.1 F-97770D7ED2DFF388BC60EAB380950A77.lisp,NONE,1.1 F-9FD71CEB3A8045B747F54A629ED92A8D.lisp,NONE,1.1 F-A30F4DBDE92A478CEB73EF64056E4340.lisp,NONE,1.1 F-A3262E4C63ABCB9396F1C019B9CAE540.lisp,NONE,1.1 F-A371BDB8A9CF854FE00C63C1264B1D99.lisp,NONE,1.1 F-A580617EC4FE7BAAC13B25642EF48CAC.lisp,NONE,1.1 F-C25BFAA9CFD16915F31BF90D03646B52.lisp,NONE,1.1 F-C534B6E74FE1BD1E409FAAFBB6DC110B.sh,NONE,1.1 F-CA4E16937768388DD32FAD6ADA8B6A2F.lisp,NONE,1.1 F-D3884C19BD6F4028992C7EE4A564DCA3.lisp,NONE,1.1 F-D3DC1953503E35C4D11154495DE074FB.lisp,NONE,1.1 F-DDFDB88C633DE12D1C1F5B3C3312FC20.lisp,NONE,1.1 F-E3131BB19D8294EBDA5E9BFD1C50BB5D.lisp,NONE,1.1 F-E8B8309E1270A0D1EDB0FB64AB2298D2.lisp,NONE,1.1 F-E9DFED59ECE7621E4773E6B51E9D2881.lisp,NONE,1.1 F-F3CA06292A3D8237E960CB2844A8D5C0.lisp,NONE,1.1 F-FABFD2A24671001E7FA5E630FED91059.lisp,NONE,1.1 F-FD67F73260C22A0EC7EF43A6F702E80F.lisp,NONE,1.1 MAP,1.8,1.9 F-00C35BDA7066AC107B37940B8A805C05.lisp,1.1,NONE F-025D9893A3E0354B85A37E769E151F35.lisp,1.1,NONE F-028A9D98A2C
Message-ID: <200512021048.jB2AmMN07852@bat.berlios.de>

Update of /cvsroot/gennf/gennf
In directory sheep:/tmp/cvs-serv20164

Modified Files:
	MAP 
Added Files:
	F-01BFC84C7B5AA5916B1FC95B481B0DEC.lisp 
	F-1474E393BE5A7EE83A4D941FA7F9346D.lisp 
	F-14CAFC7D376F98290437724D067E63D4.lisp 
	F-1923CF213AD21CBF66474E7C068BFECD.lisp 
	F-21E77680CDA9B7DA5133627E47FA0987.lisp 
	F-24AFFF4D581EFC1C6EF802B4AAB5D27B.lisp 
	F-32A3BA955BE6E0F48ABEDF5C42137D5E.lisp 
	F-389E31FE3917AE1504A5DED502AE3D51.lisp 
	F-3C5788EDE4B0D9B8845BDDF41278246B.lisp 
	F-3CDB81902ABA8CED95DEEBDA8590315E.lisp 
	F-40CE98E89C297E85E8209004EE49D372.lisp 
	F-418A4A44531B20FCEB6851D533A75A04.lisp 
	F-4F2D9B26F5FB9FA0F66EBB82BE7E8EF1.lisp 
	F-4F34E424D04A8DF9D18E24CFE19D425C.lisp 
	F-54A44C0786853024F450D715BBB3997E.lisp 
	F-5B815906BE2D64E9BC2E48B76242BFF2.lisp 
	F-6763C87866B0E9BE56C154839D6FAB55.lisp 
	F-6C2D433380C1B1B204522582A4F30484.lisp 
	F-74915F0862B511AC9C233FDCB87DBEF8.lisp 
	F-7849808E8711BA9FBEB0917F33B12A79.lisp 
	F-8E73F07FB339A6981C69AF06C278B49A.lisp 
	F-97770D7ED2DFF388BC60EAB380950A77.lisp 
	F-9FD71CEB3A8045B747F54A629ED92A8D.lisp 
	F-A30F4DBDE92A478CEB73EF64056E4340.lisp 
	F-A3262E4C63ABCB9396F1C019B9CAE540.lisp 
	F-A371BDB8A9CF854FE00C63C1264B1D99.lisp 
	F-A580617EC4FE7BAAC13B25642EF48CAC.lisp 
	F-C25BFAA9CFD16915F31BF90D03646B52.lisp 
	F-C534B6E74FE1BD1E409FAAFBB6DC110B.sh 
	F-CA4E16937768388DD32FAD6ADA8B6A2F.lisp 
	F-D3884C19BD6F4028992C7EE4A564DCA3.lisp 
	F-D3DC1953503E35C4D11154495DE074FB.lisp 
	F-DDFDB88C633DE12D1C1F5B3C3312FC20.lisp 
	F-E3131BB19D8294EBDA5E9BFD1C50BB5D.lisp 
	F-E8B8309E1270A0D1EDB0FB64AB2298D2.lisp 
	F-E9DFED59ECE7621E4773E6B51E9D2881.lisp 
	F-F3CA06292A3D8237E960CB2844A8D5C0.lisp 
	F-FABFD2A24671001E7FA5E630FED91059.lisp 
	F-FD67F73260C22A0EC7EF43A6F702E80F.lisp 
Removed Files:
	F-00C35BDA7066AC107B37940B8A805C05.lisp 
	F-025D9893A3E0354B85A37E769E151F35.lisp 
	F-028A9D98A2C6CC50B4EE0B2628784ABC.ist 
	F-0571E3ADC3C861BB4201C0D50BBD080F.lisp 
	F-07ECAC7A6912ACBD1F58136F8C7851FC 
	F-07F5F323E1470D45AE3797943D9F09C0.lisp 
	F-0B3DE1676D640B6284B2AB52D6EA8EB4 
	F-0DB6763AB5A2920F71ECAA622A0080EB 
	F-0F588B44AA6134780FC75F766E81718A.lisp 
	F-0FDB5E35B3A7F9BF1BD884EF53696A55.lisp 
	F-1133F35CE972E157EB008BF7968FA4EB.lisp 
	F-1741BA39562AC666349637CAD1C2FE22.lisp 
	F-184B4E916574917A6C9E0EE01159F4FA.lisp 
	F-18B9CB29CA124180C8F2C5BF00637E1A.lisp 
	F-2A21AE075C3E7DF766F800FA4BD14C92.lisp 
	F-2DB6E4F50A2F184866E02786BC116057 
	F-317EC0D21972EC27E3AD31F6585E43C6.lisp 
	F-319FF2C164F29F9653561D842E7235CE.lisp 
	F-32231FAFC8CBEDAAC480487558AC4161.lisp 
	F-3233593F7DB15EC4F2A2E6E89CEF9357.lisp 
	F-37A2AE760DB6B6B72D9EB9CE1FA7B1DA.lisp 
	F-37F38DA9F697247D7C16D57637448F68.lisp 
	F-3AA88479885D9ADF2B9919237F3A6272 
	F-3B6DEE3AF3E274361CBAC091A01B06BD.lisp 
	F-3EB579DE389A5EE173021BEC02BA59BE.lisp 
	F-4734C5CBB656981507155EF842738409.lisp 
	F-479BF655B94AC8236F1B1655CDA889B8.lisp 
	F-49A639980544EBC9EE5219DABA1B7ABC.lisp 
	F-4C367C3FCE5E39D0D091F2F7004E720C.lisp 
	F-4DA86A8AB987565A410E8A6254281DB6.lisp 
	F-4F7212DDF5CB055227A020E4503020B8.lisp 
	F-503EB9C1ED94503BE865AE52C2BBEB43.lisp 
	F-57795A1A0A45E15ECB67B6597426E8D0.lisp 
	F-59B8F91B14178E72E2EE11D6218CAC70.lisp 
	F-5C432E7F33D77F8EFDB047B6A42B7B75.sh 
	F-5F74E0CDBCCED50B7F581BBE6F00FAF9.lisp 
	F-5F9B4F1F7061BD1C399594B681CB0FB2.lisp 
	F-5FE639B12E294972A2CBE027D579B0BB.sh 
	F-605D165A2362E2E68637D8C6B8FEDD72 
	F-60EEA232662DB891B60E86DD118F1635 
	F-61163B6E9FB184FE5FFDEEF2F1A2B4E3.lisp 
	F-634B9707B2ACF7059577CF74C6098D32.lisp 
	F-63943879FE8CCC8BF69C0A0ED0B07B4C.lisp 
	F-64ACAF6D7F846228100313CD78197481.lisp 
	F-650AE495558EEDC296536D1625FB0293.lisp 
	F-69DE21066EED94595C02FFE4D67ADA71.c 
	F-6A3B8283DEC0D30CC3ABE1585C767F64 
	F-747F81C82C72BFA612378BB6721B4704.lisp 
	F-7728805CEA8BF8B5B162C89BEEF8C673.sh 
	F-8060FF37280530E28B7AACEDBCE90B32.lisp 
	F-8592E33D84C8F2674CE53AC0BC62941C.lisp 
	F-861F3E07A039F60A03D9A26BCDD4D7AC.lisp 
	F-87735485B9B38C990B088267B2215327.lisp 
	F-88A0F15C04414A0935B59A1AD29E382F.lisp 
	F-89F6E5CF7D4C0F48870071E4465CF225.lisp 
	F-8E719B54590CDE2E0C00E5DC2255C0B1.sh 
	F-8F812984949A67FDDD1B3E267B82C1FD 
	F-
--- NEW FILE: F-01BFC84C7B5AA5916B1FC95B481B0DEC.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "mapping")
(require "system")
(require "print")
(require "seqfuncs")
(provide "types")

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defconstant *mcvs-types-name* "TYPES"))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defconstant *mcvs-types* #.(path-cat *mcvs-dir* *mcvs-types-name*))
  (defconstant *mcvs-new-types* #.(path-cat *mcvs-dir* "TYPES-NEW")))

(defconstant *types-comments*
";;; For each file suffix that appears in the file set, you can specify
;;; the CVS keyword expansion mode, or you can specify that the files having
;;; that suffix should not be imported. This is done by editing the list below.
;;; Here are the symbols you can specify next to each suffix.
;;;
;;;   :default    Expand keyword using default form. (CVS -kkv)
;;;   :name-only  Expand only the keyword name on checkout. (CVS -kk)
;;;   :keep-old   Do not expand keywords, and keep any CVS or RCS keywords
;;;               that are already present in the files. (CVS -ko)
;;;   :binary     Like :keep-old except that the file is treated as
;;;               binary. Not only are keywords not expanded, but line ending
;;;               conversions are not performed either. (CVS -kb)
;;;   :value-only Expand only the keyword value, no dollar signs. (CVS -kv)
;;;   :ignore     Do not import or add these files.
")


(defun types-read (filename)
  (let ((*read-eval* nil))
    (with-open-file (file filename :direction :input)
      (read file))))

(defun types-write (types filename &key comments)
  (when *dry-run-option*
    (chatter-debug "not writing to ~a because of -n global option.~%" 
		   *mcvs-types*)
    (return-from types-write))
  (with-open-file (file filename :direction :output)
    (let ((sorted-types (sort (copy-list types)
			      #'string-lessp :key #'first)))
      (when comments
	(write-string comments file)
	(terpri file))
      (print-assoc-list sorted-types file)
      (terpri file))))

(defun types-sanity-check (types)
  (cond
    ((null types) 
       (values))
    ((consp types)
       (let ((type-spec (first types)))
	 (when (or (not (stringp (first type-spec)))
		   (not (symbolp (second type-spec))))
	   (error "bad syntax in file type treatment specification: ~s" type-spec))
	 (when (not (member (second type-spec)
			    '(:name-only :keep-old :default :value-only
			      :binary :ignore)))
	   (error "unrecognized keyword: ~s" type-spec))) 
       (types-sanity-check (rest types)))
    (t (error "bad syntax in file type treatment specification: ~s" types))))

(defun types-to-import-wrapper-args (types)
  (mapcan #'(lambda (type-spec)
	      (destructuring-bind (suffix treatment) type-spec
		(flet ((gen-option (suf opt)
			 (list "-W" (format nil "*.~a -k '~a'" suf opt))))
		  (ecase treatment
		    ((:name-only) (gen-option suffix "k"))
		    ((:keep-old) (gen-option suffix "o"))
		    ((:binary) (gen-option suffix "b"))
		    ((:value-only) (gen-option suffix "kv"))
		    ((:ignore) nil)
		    ((:default) nil))))) 
	  types))

(defun types-remove-ignores (types mapping)
  (let ((ignores (mapcan #'(lambda (type-spec)
			     (if (eq (second type-spec) :ignore)
			       (list (first type-spec))))
			 types)))
    (remove-if #'(lambda (entry)
		   (with-slots (kind id) entry
		     (and (eq kind :file)
			  (member (suffix id) ignores :test #'path-equal))))
	       mapping)))

(defun types-make-cvs-adds (types mapping)
  (let (cvs-adds matching files)
    (dolist (type-entry types)
      (multiple-value-setq 
	(matching mapping)
	(separate-if #'(lambda (x)
			 (and x (path-equal (first type-entry) x)))
		     mapping
		     :key #'(lambda (x) (suffix (mapping-entry-id x)))))
      (setf files (mapcar #'basename (mapcar #'mapping-entry-id matching)))
      (when files
	(ecase (second type-entry)
	  ((:name-only) (setf files (list* "-kk" files)))
	  ((:keep-old) (setf files (list* "-ko" files)))
	  ((:binary) (setf files (list* "-kb" files)))
	  ((:value-only) (setf files (list* "-kv" files)))
	  ((:ignore) (setf files nil))
	  ((:default)))
	(when files (push files cvs-adds))))
    (setf files (mapcar #'basename (mapcar #'mapping-entry-id mapping)))
    (when files (push files cvs-adds))
    cvs-adds))

(defun types-let-user-edit (types filename)
  (when types
    (types-write types filename :comments *types-comments*)
    (loop 
      (loop
	(restart-case
	  (progn 
	    (chatter-debug "Editing types.~%")
	    (unless (invoke-editor-on filename)
	      (error "Failed to invoke text editor."))
	    (return))
	  (retry ()
	    :report "Try invoking editor again.")))
      (restart-case
	(let ((edited-types (types-read filename)))
	  (types-sanity-check edited-types)
	  (types-write edited-types filename)
	  (return edited-types))
	(retry ()
	  :report "Correct file type treatment, try again.")
	(restore-types ()
	  :report "Revert to original file treatment and edit again."
	  (types-write types filename :comments *types-comments*))))))

--- NEW FILE: F-1474E393BE5A7EE83A4D941FA7F9346D.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "generic")
(provide "watch")

(defun mcvs-watch (mcvs-opts watch-opts files)
  (when (> (length watch-opts) 1)
    (error "only one option can be specified"))
  (find-bind (:test #'string= :key #'first)
	     ((on "on") (off "off")
	      (add "add") (remove "remove"))
	     watch-opts
    (let ((watch-args (cond
			(on '("on"))
			(off '("off"))
			(add `("add" "-a" ,(second add)))
			(remove `("remove" "-a" ,(second remove)))
			(t (error "no watch option specified")))))
      (mcvs-generic "watch" mcvs-opts nil watch-args files))))

(defun mcvs-watch-wrapper (mcvs-opts command-opts command-args)
  (mcvs-watch mcvs-opts command-opts command-args))

--- NEW FILE: F-14CAFC7D376F98290437724D067E63D4.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "dirwalk")
(require "mapping")
(provide "remap")

(defun mcvs-remap ()
  (in-sandbox-root-dir
    (let* ((old-mapping (mapping-read *mcvs-map-local*))
	   (cvs-mapping (mapping-read *mcvs-map*))
	   (inode-hash (make-hash-table :test #'eql))
	   (new-mapping (remove-if #'(lambda (entry)
				       (with-slots (path kind) entry
					 (and (eq kind :file)
					      (real-path-exists path))))
				   old-mapping)))
      (restart-case
	(when (not (equal-filemaps old-mapping cvs-mapping))
	  (error "local and repository mappings differ."))
	(continue () :report "remap anyway, clobbering repository mapping"))
      (dolist (entry old-mapping)
	(with-slots (id kind) entry
	  (when (eq kind :file)
	    (let ((file-info (no-existence-error (stat id))))
	      (unless file-info
		(restart-case
		  (error "~a does not exist." id)
		  (continue () :report "Remove it from the map.")))
	      (when file-info
		(setf (gethash (inode file-info) inode-hash) entry))))))
      (for-each-file-info (fi ".")
	(let* ((path (canonicalize-path (file-name fi)))
	       (abs-path (real-to-abstract-path path)))
	  (cond 
	    ((regular-p fi)
	      (let ((entry (gethash (inode fi) inode-hash)))
		(when entry
                  (let ((new-entry (copy-mapping-entry entry)))
		    (setf (mapping-entry-executable new-entry)
			  (executable-p fi))
                    (setf (mapping-entry-path new-entry) abs-path)
		    (push new-entry new-mapping)
		    (setf (gethash (inode fi) inode-hash) nil)))))
	    ((symlink-p fi)
	      (chatter-info "skipping symbolic link ~a.~%" path))
	    ((directory-p fi)
	      (when (path-equal path *mcvs-dir*)
		(skip))))))
      (mapping-write new-mapping *mcvs-map-local* :sort-map t)
      (mapping-write new-mapping *mcvs-map* :sort-map t))))

(defun mcvs-remap-wrapper (global-options command-options args)
  (declare (ignore global-options command-options))
  (when args
    (error "command takes no arguments."))
  (mcvs-remap))

--- NEW FILE: F-1923CF213AD21CBF66474E7C068BFECD.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(provide "split")

(defun split-fields (in-string delim-char-bag)
"Split string into rigid fields based on delimiter characters. 
Each individual delimiter character separates two fields.
Example:  (split-fields \":c:#a\" \":#\") ==> (\"\" \"c\" \"\" \"a\")"
  (let (list (tok-start 0))
    (if (= (length delim-char-bag) 1)
      (let ((delim (aref delim-char-bag 0)))
	(dotimes (index (length in-string)) 
	  (when (char= delim (char in-string index))
	    (push (subseq in-string tok-start index) list)
	    (setf tok-start (1+ index)))))
      (dotimes (index (length in-string)) 
	(when (find (char in-string index) delim-char-bag :test #'char=)
	    (push (subseq in-string tok-start index) list)
	    (setf tok-start (1+ index)))))
    (push (subseq in-string tok-start) list)
    (nreverse list)))

(defun split-words (in-string delim-char-string)
"Munge sequences of delimiter characters. The pieces
in between are returned as a list of strings.
Example:  (split-words \" a b cde f \"  \" \") ==> (\"a\" \"b\" \"cde\" \"f\")"
  (let (list (token "") (state :parsing-delim))
    (dotimes (i (length in-string))
      (let ((ch (aref in-string i)))
        (if (not (find ch delim-char-string))
          (progn (setf token (format nil "~a~a" token ch))
                 (setf state :parsing-token))
          (when (eq state :parsing-token)
            (push token list)
            (setf token "")
            (setf state :parsing-delim)))))
    (when (not (equal token ""))
      (push token list))
    (nreverse list)))

#| (time (dotimes (x 1000) (split-fields "aaa:bb:ccc:ddd:eee" ":"))) |#


--- NEW FILE: F-21E77680CDA9B7DA5133627E47FA0987.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "chatter")
(require "find-bind")
(provide "error")

(defvar *mcvs-error-treatment* :interactive
"This variable is used by the top level error handler set up in mcvs-execute to
decide on what to do with a restartable error condition.  If no restarts are
available, then this variable is ignored; the handler will print the error
message and terminate the program.  If the error is restartable, then this
variable is examined. A value of :interactive indicates that a menu of options
should be presented to a user, who can choose to terminate the program,
or invoke one of the available restarts. A value of :continue means
to emit a warning message and then invoke the a continue restart if
one is available. If restarts are available, but not ones that can
be automatically selected by the handler, then it will terminate the
program. A value of :terminate means to terminate on error, restartable
or not. A value of :decline means to return normally handling the error.")

(defvar *mcvs-errors-occured-p* nil)

(defvar *interactive-error-io* nil)

(defun mcvs-terminate (condition)
  (format *error-output* "mcvs: ~a~%" condition)
  (throw 'mcvs-terminate t))

(defun mcvs-error-handler (condition)
  (let ((*print-escape* nil))
    (setf *mcvs-errors-occured-p* t)
    (find-bind (:key #'restart-name)
	       (others (continue 'continue)
		       (info 'info)
		       (retry 'retry))
	       (compute-restarts)
      (ecase *mcvs-error-treatment*
	((:interactive)
	   (unless *interactive-error-io*
	     (return-from mcvs-error-handler nil))
	   (when (null (compute-restarts))
	     (mcvs-terminate condition))
	   (let* (command-list
		  (menu (with-output-to-string (stream)
			  (format stream "~%The following error has occured:~%~%")
			  (format stream "    ~a~%~%" condition)
			  (format stream "You have these alternatives:~%~%")
			  (format stream "    ?) Re-print this menu.~%" continue)
			  (when info
			    (format stream "    I) (Info) ~a~%" info)
			    (push (list "I" #'(lambda () 
						(invoke-restart info)))
				  command-list))
			  (when continue
			    (format stream "    C) (Continue) ~a~%" continue)
			    (format stream "    A) Auto-continue all continuable errors.~%")
			    (push (list "C" #'(lambda () 
						(invoke-restart continue)))
				  command-list)
			    (push (list "A" #'(lambda () 
						(setf *mcvs-error-treatment*
						      :continue)
						(invoke-restart continue)))
				  command-list))
			  (when retry
			    (format stream "    R) (Retry) ~a~%" retry)
			    (push (list "R" #'(lambda () 
						(invoke-restart retry)))
				  command-list))
			  (format stream "    T) Recover, clean-up and terminate.~%")
			  (push (list "T" #'(lambda ()
					      (throw 'mcvs-terminate t)))
				command-list)
			  (when others
			    (format stream "~%These special alternatives are also available:~%~%")
			    (let ((counter 0))
			      (dolist (restart others)
				(format stream "    ~a) ~a~%" (incf counter) restart)
				(push (list (format nil "~a" counter)
					    (let ((restart restart))
					      #'(lambda () 
						  (invoke-restart restart))))
				      command-list))))
			  (terpri stream))))
	     (write-string menu *interactive-error-io*)
	     (loop 
	       (write-string ">" *interactive-error-io*)
	       (let* ((line (read-line *interactive-error-io*))
		      (command (find line command-list 
				     :key #'first 
				     :test #'string-equal)))
		 (cond
		   ((string= line "?")
		     (write-string menu *interactive-error-io*))
		   (command
		     (funcall (second command)))
		  (t (format *interactive-error-io* "What?~%")))))))
	((:continue)
	   (when continue
	     (chatter-terse "Auto-continuing error:~%")
	     (chatter-terse "    ~a~%" condition)
	     (invoke-restart continue))
	   (mcvs-terminate condition))
	((:terminate)
	   (mcvs-terminate condition))
	((:decline)
	   (return-from mcvs-error-handler nil))))))

--- NEW FILE: F-24AFFF4D581EFC1C6EF802B4AAB5D27B.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

#+(or clisp cmu18c) (require "posix")

#+(and clisp clisp-unix-funcs) 
  (require "clisp-unix")

#+(and clisp (not clisp-unix-funcs)) 
  (require "clisp-linux")

#+cmu18c 
  (require "cmucl-unix")

--- NEW FILE: F-32A3BA955BE6E0F48ABEDF5C42137D5E.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(require "dirwalk")
(require "chatter")
(require "split")
(require "mapping")
(require "types")
(require "rcs-utils")
(provide "convert")

(defun remove-attic-component (path)
  (let ((split-path (nreverse (split-fields path "/")))
	(attic-p nil))
    (when (string= (first split-path) "Attic")
      (pop split-path)
      (setf attic-p t))
    (values (reduce #'(lambda (x y) (format nil "~a/~a" x y)) 
		    (nreverse split-path)
		    :initial-value ".")
	    attic-p)))

(defun classify-tags (tags)
  (let (version-tags branch-tags)
    (dolist (tag tags (values version-tags branch-tags))
      (destructuring-bind (tag-name tag-value) tag
	(if (search ".0." tag-value)
	  (push tag-name branch-tags)
	  (push tag-name version-tags))))))
	
(defun mcvs-convert (source-dir target-dir)
  (when (ignore-errors (stat target-dir))
    (error "a directory or file called ~a exists here already."
           target-dir))

  (multiple-value-bind (path created) 
                       (ensure-directories-exist (path-cat target-dir 
							   *mcvs-map-name*))
    (declare (ignore path))
    (if (not created) 
      (error "unable to create directory ~a." target-dir)))

  (let (filemap all-version-tags all-branch-tags attic-made)
    (current-dir-restore
      (chdir source-dir)
      (for-each-file-info (fi ".")
	(when (and (directory-p fi)
		   (path-equal (basename (file-name fi)) "CVS"))
	  (skip))
	(when (regular-p fi)
	  (let ((canon-name (canonicalize-path (file-name fi))))
	    (multiple-value-bind (suffix basename dir) 
				 (suffix canon-name #\,)
	      (multiple-value-bind (no-attic-dir attic-p)
				   (remove-attic-component (or dir "."))
		(when (and suffix (string= suffix "v"))
		  (let* ((no-attic-suffix-name 
			   (canonicalize-path (path-cat no-attic-dir basename)))
			 (f-name (mapping-generate-id :suffix (suffix basename)
						      :no-dir t))
			 (orig-rcs (path-cat source-dir canon-name))
			 (new-rcs (apply #'path-cat `(,target-dir
						      ,@(if attic-p '("Attic"))
						      ,(format nil "~A,v" 
							       f-name)))))
		    (in-original-dir
		      (when attic-p
			(unless attic-made
			  (ensure-directories-exist new-rcs)
			  (setf attic-made t)))
		      (chatter-info "hard linking ~a -> ~a~%" orig-rcs new-rcs)
		      (link orig-rcs new-rcs))
		    (push (make-mapping-entry :kind :file
					      :id (path-cat *mcvs-dir* f-name)
					      :path no-attic-suffix-name
					      :executable (executable-p fi))
			  filemap)
		    (with-open-file (f (parse-posix-namestring canon-name) 
				       :direction :input)
		      (chatter-info "scanning ~a~%" canon-name)
		      (let ((rcs-file (rcs-parse f)))
			(multiple-value-bind (version-tags branch-tags)
					     (classify-tags (rcs-admin-symbols (rcs-file-admin rcs-file)))
			  (setf all-version-tags (nunion all-version-tags 
							 version-tags 
							 :test #'string=))
			  (setf all-branch-tags (nunion all-branch-tags branch-tags 
							:test #'string=)))))))))))))

    (current-dir-restore
      (chdir target-dir)
      (chatter-info "writing ~a~%" *mcvs-map-name*)
      (mapping-write filemap *mcvs-map-name* :sort-map t)

      (chatter-info "writing ~a~%" *mcvs-types-name*)
      (with-open-file (f *mcvs-types-name* :direction :output)
	(prin1 nil f)
	(terpri f))

      (chatter-info "writing .cvsignore~%")
      (with-open-file (f (make-pathname :name ".cvsignore") :direction :output)
	(write-line *mcvs-map-local-name* f)
	(write-line *mcvs-displaced-name* f))

      (execute-program `("ci" "-mCreated by Meta-CVS convert operation."
			 "-t/dev/null" ,*mcvs-map-name* 
			 ,*mcvs-types-name* ".cvsignore"))
      (execute-program `("chmod" "ug+rw" ,(format nil "~A,v" *mcvs-map-name*)))

      (chatter-info "setting up version and branch tags in ~a, ~a and .cvsignore~%" 
		    *mcvs-map-name* *mcvs-types-name*)
      (unless (null all-version-tags)
	(execute-program-xargs '("rcs") 
			       (mapcar #'(lambda (tag)
					   (format nil "-n~A:1.1" tag))
				       all-version-tags)
			       (list *mcvs-map-name* *mcvs-types-name* 
				     ".cvsignore")))

      (let ((branch-counter 0))
	(unless (null all-branch-tags)
	  (execute-program-xargs '("rcs")
				 (mapcar #'(lambda (tag)
					     (format nil 
						     "-n~A:1.1.0.~A" 
						     tag (incf branch-counter 
							       2)))
					 all-branch-tags)
				 (list *mcvs-map-name* *mcvs-types-name*
				       ".cvsignore")))))))

(defun mcvs-convert-wrapper (cvs-options cvs-command-options mcvs-args)
  (declare (ignore cvs-options cvs-command-options))
  (if (/= (length mcvs-args) 2)
    (error "specify cvs source dir and new target dir."))
  (mcvs-convert (first mcvs-args) (second mcvs-args)))

(defconstant *convert-help*
"Syntax:

  mcvs convert source-cvs-module target-mcvs-module

Options:

  None.

Semantics:

  The convert command builds a Meta-CVS module directly out of the RCS files of
  a CVS module.  The source-cvs-module is the pathname to an existing
  module directory in the CVS repository containing an ordinary CVS module.
  The target-mcvs-module is the pathname of a new Meta-CVS module directory to
  be created. 
  
  The source and target paths have to be on the same filesystem volume.

  The chmod and rcs programs are required.

  The algorithm is extremely naive:
  
  - A list of the pathnames of the RCS files is collected, as the basis for
  creating the MAP file. The Attic directory components are removed from these
  paths, and the ,v suffixes are stripped.

  - The execute property of files is lifted from the permission bits on
  the RCS files.

  - The MAP,v file is created using the ``rcs ci'' command.

  - The F- files are generated as hard links to the RCS files, to save space
  and avoid the overhead of copying.

  - All of the RCS files are scanned to find version and branch tags.  Quite
  naively, the version tags are installed in the MAP file, all pointing to
  revision 1.1. The branch tags are installed in MAP, pointing to revisions
  1.1.0.2, 1.1.0.4, ...  This is a lame attempt to make it possible to check
  out past baselines. But note that the contents of MAP don't vary: only a
  single version node is generated with a fixed set of files. It is not taken
  into consideration that some of the CVS files may be deleted in the head
  revision or some branches.  Therefore, when the resulting Meta-CVS project is
  checked out, or when past versions are retrieved, there may be complaints
  from Meta-CVS about nonexistent files.

  The complaints about nonexistent files may be fixed at the tips of the
  main trunk or branches using the ``mcvs remap'' command which will purge
  the working MAP of entries for F- files for which no working copy is found.
  A commit will then commit the change so that subsequent work may continue
  without any more complaints.
 
  The hard linking of the original RCS objects under F- names means that any
  permission, ownership or time-stamp changes done in the CVS module will
  affect the content of the Meta-CVS module and vice versa. Destructive
  modifications to the file contents, ditto. Be careful!

  If the hard links make you nervous, do a deep copy of the module,
  using ``cp -a source-dir target-dir''.

  Note that CVS does not destructively manipulate RCS files. A commit
  or tagging operation creates a new RCS object which atomically replaces the
  old hard link. This means that a commit to a file in the Meta-CVS module will
  not affect the CVS module and vice versa.")

--- NEW FILE: F-389E31FE3917AE1504A5DED502AE3D51.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(provide "print")

(defun print-assoc-list (alist &optional (stream *standard-output*))
"Print an association list in this nice form
 ((a b ...)
  (c d ...)
  ...
  (e f ...))"
 (cond
   ((null alist)
      (write nil :stream stream))
   ((not (consp alist))
      (error "PRINT-ASSOC-LIST: ~a is not a list." alist))
   (t (format stream "(~s" (first alist))
      (loop
	(setf alist (rest alist))
	(when (null alist)
	  (write-string ")" stream)
	  (return))
	(format stream "~& ~s" (first alist))))))

--- NEW FILE: F-3C5788EDE4B0D9B8845BDDF41278246B.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(require "chatter")
(require "find-bind")
(require "split")
(require "error")
(provide "options")

(defvar *print-usage* nil)
(defvar *nometa-option* nil)
(defvar *meta-option* nil)
(defvar *metaonly-option* nil)
(defvar *dry-run-option* nil)
(defvar *nesting-escape-option* 0)

(defun option-spec-expand (num-args string-list)
  (mapcar #'(lambda (string) (list string num-args))
	  string-list))

(defmacro option-spec (&rest option-specs)
  `(append ,@(mapcar #'(lambda (spec)
			 (destructuring-bind (number word &rest strings) spec
			   (when (not (string= (symbol-name word) "ARG"))
			     (error "OPTIONS: word \"ARG\" expected."))
			   `(option-spec-expand ,number ',strings)))
		     option-specs)))

(defmacro define-option-constant (var &rest option-specs)
  `(defconstant ,var (option-spec , at option-specs)))

(defun parse-opt (arguments option-spec)
  (flet ((process-option (arg)
	   (let* ((split-opt (split-fields arg #(#\=)))
		  (opt-name (first split-opt))
		  (opt-arg (second split-opt))
		  (spec (find opt-name option-spec 
			      :test #'string= 
			      :key #'first)))
	     (when (null spec)
	       (error "unknown option ~a." opt-name))
	     (when opt-arg
	       (push opt-arg arguments))
	     (let ((num-req-params (second spec))
		   (opt-args ()))
	       (dotimes (i num-req-params)
		 (let ((opt-arg (pop arguments)))
		   (when (null opt-arg)
		     (error "option ~a requires ~a parameter~:p." 
			    opt-name num-req-params))
		   (push opt-arg opt-args)))
	       (cons opt-name (nreverse opt-args))))))
    (let ((parsed-options ()))
      (loop
	(if (null arguments)
	  (return))
	(let ((arg (pop arguments)))
	  (cond 
	    ((string= arg "--")
	       (return))
	    ((and (> (length arg) 2) (string= (subseq arg 0 2) "--"))
	       (push (process-option (subseq arg 2)) parsed-options))
	    ((and (> (length arg) 1) (char= (char arg 0) #\-))
	       (let ((num-chars (- (length arg) 1))
		     (last-iter (- (length arg) 2)))
		 (dotimes (i num-chars)
		   (let ((option (subseq arg (+ i 1) (+ i 2)))
			 (arg (subseq arg (+ i 2))))
		     (when (< i last-iter)
		       (push arg arguments))
		     (let ((result (process-option option)))
		       (push result parsed-options)
		       (when (and (second result)
				  (/= i (- (length arg) 2)))
			 (return))
		       (when (< i last-iter)
			 (pop arguments)))))))
	    (t (push arg arguments) 
	       (return)))))
      (values (nreverse parsed-options) arguments))))
		  
(defun format-opt (options)
"Convert list of options as produced by parse-opt back into a list
of strings."
  (mapcan #'(lambda (option-list)
	      (let ((option (first option-list)) 
		    (arg (rest option-list)))
		(if (> (length option) 1)
		  (cons (format nil "--~a" option) arg)
		  (if (= (length arg) 1)
		    (list (format nil "-~a~a" option (first arg)))
		    (cons (format nil "-~a" option) arg))))) 
	  options))

(defun filter-mcvs-options (opts)
"Processes and removes any Meta-CVS-specific options."
  (find-bind (:test #'string= :key #'first)
	     (remainder (meta "meta")
			(metaonly "metaonly")
			(nometa "nometa")
			(ec "error-continue") 
			(et "error-terminate")
			(nesting-escape "up")
		        (debug "debug"))
	     opts
    (when (and meta nometa)
      (error "cannot specify both --nometa and --meta"))
    (when (and metaonly nometa)
      (error "cannot specify both --nometa and --metaonly"))
    (setf *meta-option* meta)
    (setf *metaonly-option* metaonly)
    (setf *nometa-option* nometa)
    (when nesting-escape
      (unless (setf *nesting-escape-option* 
		    (parse-integer (second nesting-escape)
				   :junk-allowed t))
	(error "--up option takes integer argument"))
      (unless (>= *nesting-escape-option* 0)
	(error "--up argument must be nonnegative")))
    (when debug
      (setf *mcvs-chatter-level* *mcvs-debug*))
    (cond
      (ec (setf *mcvs-error-treatment* :continue))
      (et (setf *mcvs-error-treatment* :terminate)))
    remainder))

(defun process-cvs-options (opts)
"Take care of any CVS options that must also be interpreted by Meta-CVS."
  (find-bind (:test #'string= :key #'first) 
	     ((help-long "help") (help "H") (quiet "q")
	      (very-quiet "Q") (version "v") (version-long "version")
	      (editor "e") (interpret-file "i") (dry-run "n"))
	     opts
    (when (or help-long help)
      (setf *print-usage* t))
    (when (or version version-long)
      (let* ((vers (split-words "$Name:  $" "$:- "))
	     (major (third vers))
	     (minor (fourth vers))
	     (patch (fifth vers)))
	(if (and major minor patch)
	  (format t "Meta-CVS version ~a.~a.~a Copyright 2004 Kaz Kylheku~%"
		  major minor patch)
	  (format t "Meta-CVS unknown version Copyright 2004 Kaz Kylheku~%"))
	(throw 'mcvs-terminate nil)))
    (when editor
      (setf *mcvs-editor* (second editor)))
    (cond
      (very-quiet (setf *mcvs-chatter-level* *mcvs-silent*))
      (quiet (setf *mcvs-chatter-level* *mcvs-terse*)))
    (when dry-run
      (setf *dry-run-option* t))
    (when interpret-file
      (load (second interpret-file))
      (throw 'mcvs-terminate nil)))
  opts)

(defun filter-global-options (opts)
  (process-cvs-options (filter-mcvs-options opts)))

(defmacro honor-dry-run (vars &rest forms)
  `(cond
     (*dry-run-option*
       (chatter-debug 
	 "Because of -n option, not executing ~s with bindings ~s.~%"
	 ',forms
	 (list ,@(mapcar #'(lambda (var) `(list ',var ,var)) vars))))
     (t , at forms)))

--- NEW FILE: F-3CDB81902ABA8CED95DEEBDA8590315E.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(provide "chatter")

(defconstant *mcvs-debug* 3)
(defconstant *mcvs-info* 2)
(defconstant *mcvs-terse* 1)
(defconstant *mcvs-silent* 0)

(defvar *mcvs-chatter-level* *mcvs-info*)
(declaim (special *mcvs-chatter-level*))

(defun chatter (level &rest args)
  (when (>= *mcvs-chatter-level* level)
    (write-string "* " *error-output*)
    (apply #'format *error-output* args)))

(defmacro chatter-debug (&rest args)
  `(chatter *mcvs-debug* , at args))

(defmacro chatter-info (&rest args)
  `(chatter *mcvs-info* , at args))

(defmacro chatter-terse (&rest args)
  `(chatter *mcvs-terse* , at args))

--- NEW FILE: F-40CE98E89C297E85E8209004EE49D372.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "dirwalk")
(require "chatter")
(require "sync")
(require "options")
(require "find-bind")
(provide "checkout")

(defun mcvs-checkout (module &optional subdir cvs-options checkout-options
			     &key no-generate behave-like-export)
  (when subdir
    (when (path-absolute-p subdir)
      (error "subdirectory path must be relative"))
    (multiple-value-bind (canon-subdir out-of-bounds) 
			 (canonicalize-path subdir)
      (declare (ignore canon-subdir))
      (when out-of-bounds
	(error "subdirectory path ~a leads outside of module."
	       subdir))))
  (find-bind (:key #'first :test #'string= :take #'second) 
	     (cvs-checkout-options (dir "d" (or subdir module))) 
	     checkout-options
    (let ((checkout-dir (canonicalize-path dir))
	  path checkout-okay created-dir created-mcvs-dir)
      (multiple-value-setq (path created-dir) 
        (ensure-directories-exist (path-cat checkout-dir *mcvs-dir*)))
      (unwind-protect
	(current-dir-restore
	  (chdir checkout-dir)

	  (when (ignore-errors (stat *mcvs-dir*))
	    (error "directory ~a seems to be the root of an existing sandbox."
		   checkout-dir))

	  (chatter-debug "Invoking CVS.~%")
	  (unless
	    (execute-program `("cvs" ,@(format-opt cvs-options) 
			       ,(if behave-like-export "export" "checkout") 
			       "-d" ,*mcvs-dir*
			       ,@(format-opt cvs-checkout-options) ,module))
	    (error "CVS checkout failed."))

	  (unless (ignore-errors (stat *mcvs-dir*))
	    (error "checkout failed to create ~a directory." 
		   *mcvs-dir*))

	  (setf created-mcvs-dir t)
	  (mapping-write nil *mcvs-map-local*)
	  (if subdir
	    (displaced-path-write (concatenate 'string 
					       (canonicalize-path subdir)
					       *path-sep*)))
	  (unless no-generate
	    (in-sandbox-root-dir
	      (chatter-debug "Generating file structure.~%")
	      (mapping-update)))
	  (chatter-info "Checkout to directory ~a completed.~%" checkout-dir)
	  (setf checkout-okay t))
	(when (or behave-like-export (not checkout-okay))
	  (when created-mcvs-dir
	    (delete-recursive (path-cat checkout-dir *mcvs-dir*))))
	(unless checkout-okay
	  (when created-dir
	    (delete-recursive checkout-dir))))
      (values))))

(flet ((err () 
	 (error "specify module, and optional subdirectory")))
  (defun mcvs-checkout-wrapper (global-options command-options args)
    (when (< (length args) 1)
      (err))
    (destructuring-bind (module &optional subdir &rest superfluous) args
      (when superfluous
	(err))
      (mcvs-checkout module subdir global-options command-options)))

  (defun mcvs-export-wrapper (global-options command-options args)
      (when (< (length args) 1)
	(err))
      (destructuring-bind (module &optional subdir &rest superfluous) args
	(when superfluous
	  (err))
	(find-bind (:test #'string= :key #'first)
		   ((revision "r")
		    (date "D"))
		   command-options
	  (cond
	    ((not (or revision date))
	       (error "specify tag with -r or date with -D."))
	    ((and revision date)
	       (error "both -r and -D specified.")))

	  (mcvs-checkout module subdir global-options command-options 
			 :behave-like-export t)))))

(defconstant *checkout-help*
"Syntax:

  mcvs co [ options ] module-name [ subdirectory-path ]

Options:

  -f                Force a head revision match if tag or date is not found.
  -r revision       Check out specific revision or branch and make it sticky.
  -D date           Check out by date.
  -d dir            Check out into specified directory instead of creating
                    a directory based on the module name. 
  -k key-expansion  Specify RCS keyword expansion option.
  -j revision       Merge in the changes between current revision and rev.
                    Note that Meta-CVS has branch and merge commands; using
                    the -j options of checkout or update bypasses the
                    Meta-CVS merge system.

Semantics:

  The checkout command retrieves a module from Meta-CVS to form a working copy,
  also known as a ``sandbox'' in version control jargon. 

  By default, a subdirectory is created whose name is the same as the
  module-name. The module's directory structure is unfolded down there. An
  alternate directory can be specified with the -d option. Meta-CVS will
  try to create the checkout directory if it does not exist. Populating
  an existing directory is safe; Meta-CVS will stop if it encounters
  any conflicting local files.

  If the optional subdirectory-path parameter is specified, Meta-CVS will
  create a ``partial sandbox'', whose root directory is the specified
  path. This parameter is understood to be a relative path within the
  module's tree structure, resolved with respect to the root. For example
  if the module has a lib/zlib subdirectory, then specifying lib/zlib
  will create a sandbox whose root directory corresponds to lib/zlib.
  Files not under lib/zlib won't be visible in the sandbox. A nonexistent
  path can be specified; in that case the partial sandbox will be empty. Adding
  new files within the sandbox will cause the path to exist. For example,
  if the module contains no directory called lib/libdes it's still possible
  to check out that directory. Then adding a file called foo.c in the
  root directory of the sandbox will actually add a lib/libdes/foo.c file
  to the module.")

(defconstant *export-help*
"Syntax:

  mcvs export { -D date | -r revision } [ options ] 
       module-name [ subdirectory-path ]

Options:

  -f                Force a head revision match if tag or date is not found.
  -r revision       Check out specific revision or branch and make it sticky.
  -D date           Check out by date.
  -d dir            Check out into specified directory instead of creating
                    a directory based on the module name. 
  -k key-expansion  Specify RCS keyword expansion option.

Semantics:

  The export command is almost the same as the checkout command. Unlike
  checkout, export does not create a MCVS subdirectory, and so the result is
  not a working copy.  It requires that a document baseline be specified by
  symbolic revision or date.  Lastly, it does not accept the -j option to
  specify merging (but this way of merging on checkout is deprecated in
  Meta-CVS; do not use it with managed branches).")

--- NEW FILE: F-418A4A44531B20FCEB6851D533A75A04.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "dirwalk")
(require "system")
(require "mapping")
(require "types")
(require "chatter")
(require "options")
(require "restart")
(provide "create")

(defun mcvs-create (module release &optional global-options command-options)
  (multiple-value-bind (path created) (ensure-directories-exist *mcvs-map*)
    (declare (ignore path))
    (if (not created) 
      (error "A ~a directory already exists here." *mcvs-dir*)))

  (let ((preserve-mcvs-dir nil))
    (unwind-protect 
      (progn
	(let (filemap types)
	  (chatter-debug "Mapping.~%")
	  
	  ;; Gather up list of files to import, and build up mapping,
	  ;; as well as list of suffixes (file types).
	  (for-each-file-info (fi ".")
	    (cond
	      ((regular-p fi)
		 (let* ((path (canonicalize-path (file-name fi)))
			(suffix (suffix (file-name fi)))
			(file (mapping-generate-id :suffix suffix)))
		   (chatter-info "~a <- ~a~%" file path)
		   (push (make-mapping-entry :kind :file
					     :id file
					     :path path
					     :executable (executable-p 
							   fi))
			 filemap)
		   (when suffix
		     (setf types (adjoin (list suffix :default) 
					 types :test #'equal)))))
	      ((symlink-p fi)
		 (let ((path (canonicalize-path (file-name fi)))
		       (id (mapping-generate-id :prefix "S-" :no-dir t)))
		   (chatter-info "~a <- ~a~%" id path)
		   (push (make-mapping-entry :kind :symlink
					     :id id
					     :path path
					     :target (readlink path))
			 filemap)))))
				

	  ;; Write out types to file and allow user to edit.
	  (setf types (types-let-user-edit types *mcvs-types*))

	  ;; Detect backup files or other crud written by 
	  ;; user's text editor.
	  (current-dir-restore
	    (chdir *mcvs-dir*) 
	    (let (crud)
	      (for-each-path (p ".")
		(let ((cp (canonicalize-path p)))
		  (unless (or (path-equal cp *mcvs-types-name*)
			      (path-equal cp *this-dir*))
		    (push cp crud))))
	      (when crud
		(setf preserve-mcvs-dir t)
		(super-restart-case
		  (error "Unexpected files found in ~a directory. (Text editor backups?)"
			 *mcvs-dir*)
		  (continue ()
		    :report "Delete the unexpected files."
		    (unwind))
		  (info ()
		    :report "List the names of the unexpected files."
		    (dolist (cp crud)
		      (write-line cp))))
		(dolist (cp crud)
		  (unlink cp))
		(setf preserve-mcvs-dir nil))))

	  ;; User has edited, so now we must honor all of the :IGNORE
	  ;; entries in the types, and remove the matching files from the
	  ;; mapping.
	  (setf filemap (types-remove-ignores types filemap))

	  ;; Create F-files by hard linking
	  (dolist (entry filemap)
	    (with-slots (kind id path) entry
	      (when (eq kind :file)
		(link path id))))

	  ;; Write out mapping.
	  (mapping-write filemap *mcvs-map* :sort-map t)

	  ;; Create .cvsignore file.
	  (with-open-file (f (make-pathname :directory `(:relative ,*mcvs-dir*) 
					    :name ".cvsignore")
			     :direction :output)
	    (write-line *mcvs-map-local-name* f)
	    (write-line *mcvs-displaced-name* f))

	  (loop
	    (restart-case
	      (current-dir-restore
		(chdir *mcvs-dir*) 
		(chatter-debug "Invoking CVS.~%")

		(if (not (execute-program `("cvs" ,@(format-opt global-options) 
					   "import" "-I" "!"
					   ,@(format-opt command-options)
					   ,@(types-to-import-wrapper-args types)
					   ,module "Created-by-Meta-CVS" ,release)))
		  (error "CVS import failed."))
		(return))
	      (retry ()
		:report "Try invoking CVS again.")))))
      (if preserve-mcvs-dir
	(chatter-info "not removing ~a directory~%" *mcvs-dir*)
	(progn 
	  (chatter-debug "removing ~a directory~%" *mcvs-dir*)
	  (delete-recursive *mcvs-dir*)))))
  (values))

(defun mcvs-create-wrapper (cvs-options cvs-command-options mcvs-args)
  (if (< (length mcvs-args) 2)
    (error "specify module and release tag."))
  (destructuring-bind (module release &rest superfluous) mcvs-args
    (when superfluous
      (error "specify only module and release tag."))
    (mcvs-create module release cvs-options cvs-command-options)))

(defconstant *create-help*
"Syntax:

  mcvs create [ options ] module-name release-tag

Options:

  -d                Use a file's modification time as time of creation.
  -k subst-mode     Set default RCS keyword substitution mode.
  -I ignore-spec    Specify files to ignore in addition to whatever
                    is specified interactively. May cause problems;
                    since Meta-CVS will map these files anwyay.
  -b branch-num     Vendor branch number for CVS import. Deprecated
                    brain-damage; you should never need this.
  -m \"text ...\"     Log message.
  -W wrap-spec      CVS wrappers specification line. Keep in mind that 
                    Meta-CVS preserves suffixes only; CVS sees a
                    name like \"F-D3BC...30D5.html\".
Semantics:

  The create command makes a new Meta-CVS module from the files and symbolic
  links in the current directory, and all of its subdirectories. To work with
  the newly created module, you must check it out to create a working copy.
  The release-tag symbolically identifies the original baseline.

  There are some interactive steps involved. If any of the files have
  suffixes, like .c or .html, Meta-CVS will identify and tabulate them. 
  A text editor will pop up presenting you with an opportunity to edit
  a symbolic specification that assigns to each file type a CVS keyword
  expansion mode.")

--- NEW FILE: F-4F2D9B26F5FB9FA0F66EBB82BE7E8EF1.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(require "mapping")
(require "chatter")
(provide "prop")

(defun mcvs-prop (prop-options files)
  (in-sandbox-root-dir
    (let (entries-to-process
	  (filemap (mapping-read *mcvs-map*)))
      (chatter-debug "Preparing file list.~%")

      (if (null files)
	(setf entries-to-process 
	      (mapping-prefix-matches filemap
				      (sandbox-translate-path ".")))
	(dolist (file files)
	  (can-restart-here ("Continue preparing file list.")
	    (let* ((full-name (sandbox-translate-path file))
		   (abs-name (canonicalize-path 
			       (real-to-abstract-path full-name)))
		   (entries (mapping-prefix-matches filemap abs-name)))
	      (if (not entries)
		(error "~a is not known to Meta-CVS." full-name)
		(setf entries-to-process (nconc entries-to-process entries)))))))

      (when (and entries-to-process prop-options)
	;; do the property update
	(chatter-debug "Updating properties.~%")
	(dolist (entry entries-to-process)
	  (with-slots (raw-plist) entry
	    (loop for (option prop-name value) in prop-options do
	      (let ((indicator (intern (string-upcase prop-name) "KEYWORD")))
		(cond
		  ((string= option "set")
		     (setf (getf raw-plist indicator) t))
		  ((string= option "clear")
		     (setf (getf raw-plist indicator) nil))
		  ((string= option "value")
		     (setf (getf raw-plist indicator) (read-from-string value)))
		  ((string= option "remove")
		     (remf raw-plist indicator)))
		(mapping-entry-parse-plist entry)))))
	(chatter-debug "Writing out map.~%")
	(mapping-write filemap *mcvs-map*)
	;; propagate changes to local map.
	(chatter-debug "Updating file structure.~%")
	(mapping-update)
	;; propagate permission changes to files.
	(chatter-debug "Synchronizing.~%")
	(mapping-synchronize))))
  (values))

(defun mcvs-prop-wrapper (mcvs-opts command-opts command-args)
  (declare (ignore mcvs-opts))
  (mcvs-prop command-opts command-args))

--- NEW FILE: F-4F34E424D04A8DF9D18E24CFE19D425C.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "multi-hash")
(provide "memoize")

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun remove-key-aux-rest (lambda-list)
"Remove any trailing portion of the lambda list that starts with
one of the lambda list keywords &rest, &key, &aux or &body."
    (cond
      ((null lambda-list) nil)
      ((member (first lambda-list) '(&rest &aux &key &body)) nil)
      (t (cons (first lambda-list) (remove-key-aux-rest (rest lambda-list))))))

  (defun strip-lambda-list (list)
"Simplify a lambda list by removing occurences of &optional, stripping
away the trailing portion using REMOVE-KEY-AUX-REST, canonicalizing
simple variable forms to lists so that SYMBOL becomes (SYMBOL), and removing
initializers so that (SYMBOL INITFORM) becomes (SYMBOL). This stripped
lambda list becomes the lambda list of the hidden inner function that
implements the guts of a memoized function, and captures the recursive
calls. The &OPTIONAL parameters are reduced to required ones, and there
are no trailing &KEY or &rest parameters."
    (labels ((simplify-var-form (form)
	       (cond
		 ((eq '&optional form) nil)
		 ((symbolp form) (list form))
		 ((consp form) (list (first form)))
		 (t (error "MEMOIZE-EXPANDER: bad thing in lambda list: ~a~%"
			   form)))))
      (mapcan #'simplify-var-form (remove-key-aux-rest list))))

  (defun extract-tests (lambda-list)
"The memoize module understands special lambda lists which, as an extension
to regular Lisp lambda lists, allow the programmer to specify what test
function should be used for the hash table used to memoize over a given
parameter. This function parses such a lambda list and extracts the tests.
The subtlety here is that after the &optional keyword, the syntax changes.
For required parameters, the syntax which specifies the test is
(SYMBOL :TEST FUNCTION). For &optional paramters, the syntax becomes
(SYMBOL INITFORM :TEST FUNCTION). For any variable which doesn't specify
a test, the test is assumed to be #'eql."
    (let ((saw-optional))
      (mapcan #'(lambda (element)
		  (cond
		    ((eq '&optional element)
		       (setf saw-optional t)
		       nil)
		    ((consp element)
		       (if saw-optional
			 (destructuring-bind (var &optional init &key test) element
			    (declare (ignore var init))
			    (list (or test '#'eql)))
			 (destructuring-bind (var &key test) element
			    (declare (ignore var init))
			    (list (or test '#'eql)))))
		    (t (list '#'eql))))
	      (remove-key-aux-rest lambda-list))))

  (defun remove-tests (lambda-list)
"This function removes the :test specifications from a the memoized
function lambda list, thereby reducing it to a regular lambda list.
See the docstring for EXTRACT-TESTS for a little more information.
We need to do this to generate the outer shell of the memoized function,
which is a normal Lisp function."
    (let (saw-optional saw-key)
      (mapcar #'(lambda (element)
		  (cond
		    ((eq '&optional element)
		       (setf saw-optional t)
		       element)
		    ((eq '&key element)
		       (setf saw-key t)
		       element)
		    ((consp element)
		       (if saw-key
			 element
			 (if saw-optional
			   (destructuring-bind (var &optional init &key test) element
			      (declare (ignore test))
			      (append (list var) (if init (list init))))
			   (destructuring-bind (var &key test) element
			      (declare (ignore test))
			      var))))
		    (t element)))
	      lambda-list)))

(defun memoize-expander (name lambda-list tests body expr)
"Produce a memoized function in the form of a LABELS function that is
wrapped in a LET block. The LET block sets up the hash table, either
a regular hash table if there is one paramter, or a MULTI-HASH if
there are several parameters.  The body of the LABELS performs the 
memoization stuff with the hash tables. Note that the function
FACTOR-MEMO-LABELS depends on this structure of the LABELS nested
within the LET."
  (let ((multi-hash-sym (gensym "MULTI-HASH-"))
	(hash-result-sym (gensym "HASH-RESULT-"))
	(hash-found-sym (gensym "HASH-FOUND-"))
	(dimensions (length lambda-list)))
    `(let ((,multi-hash-sym ,(if (> dimensions 1)
			       `(make-instance 'multi-hash
					       :dimensions ,dimensions
					       :tests ,tests)
			       `(make-hash-table :test ,(second tests)))))
       (labels ((,name ,lambda-list
		  (multiple-value-bind (,hash-result-sym ,hash-found-sym)
				       ,(if (> dimensions 1)
					  `(get-multi-hash ,multi-hash-sym
							   , at lambda-list)
					  `(gethash , at lambda-list 
						    ,multi-hash-sym))
		    (if ,hash-found-sym
		      ,hash-result-sym
		      (setf ,(if (> dimensions 1)
			       `(get-multi-hash ,multi-hash-sym , at lambda-list)
			       `(gethash , at lambda-list ,multi-hash-sym))
			    (progn , at body)))))) ,expr))))

(defun factor-memo-labels (memo-labels forms)
"This function takes a list of the LET expressions, each of which is assumed to
be generated by MEMOIZE-EXPANDER, and factors them out to produce one giant
LET block with all of the LET material (hash tables) coalesced together,
enclosing one big coalesced LABELS block that defines all of the functions
together. This trick allows us to generate individual memoized inner functions
using MEMOIZE-EXPANDER, and then fuse them together to make one big
party of mutually recursive memoized functions."
  (macrolet ((destructure-memo-labels (labels &body labels-forms)
	       `(destructuring-bind (name outer-lambda 
				      (let inner-lambda &rest labels-forms)) 
				    ,labels 
		  (declare (ignorable name outer-lambda let inner-lambda
				      labels-forms))
		  , at labels-forms)))
    (flet ((extract-lets (labels)
	     (destructure-memo-labels labels
	       inner-lambda))
	   (extract-funcs (labels)
	     (destructure-memo-labels labels
	       `(,name ,outer-lambda , at labels-forms))))
      `(let ,(mapcan #'extract-lets memo-labels)
	 (labels ,(mapcar #'extract-funcs memo-labels) , at forms))))))

(defmacro define-memoized-function (name lambda-list &body forms)
"Generate a DEFUN definition for a function called NAME, placing the
body into an inner recursive function of the same name that is memoized.
Effectively, this creates a memoized function: one whose recursive calls
are automatically cached using the parameter lists as keys into a multi-level
hash table. This is an important optimization technique when the recursion
contains overlapping cases; it can reduce exponential time to polynomial time.
This macro understands a special lambda list syntax. A required parameter
normally written as SYMBOL can be written (SYMBOL :TEST FUNC) to specify a
hashing equality function FUNC for that parameter which can be #'EQ,
#'EQL, #'EQUAL or #'EQUALP. For an optional parameter, this syntax is
(SYMBOL INIT-FORM :TEST FUNC). Note that only the outer function accepts
&KEY and &REST parameters, if any are specified. The inner recursive memoized
function does not; it has a simplified lambda list."
  (let ((stripped-ll (strip-lambda-list lambda-list)))
    `(defun ,name ,(remove-tests lambda-list)
       ,(memoize-expander name stripped-ll `(list ,@(extract-tests lambda-list))
			  forms `(,name , at stripped-ll)))))

(defmacro memoized-labels ((&rest memoized-labels-list) &body forms)
"Generate a block of mutually recursive LABELS functions, making the
DEFINE-MEMOIZED-FUNCTION utility available for local functions. See
the documentation string for that macro for more details."
  (flet ((generate-labels-element (labels)
	   (destructuring-bind (name lambda-list &body labels-forms) labels
	     (let ((stripped-ll (strip-lambda-list lambda-list)))
	       `(,name ,(remove-tests lambda-list)
		   ,(memoize-expander name stripped-ll 
				      `(list ,@(extract-tests lambda-list))
				      labels-forms 
				      `(,name , at stripped-ll)))))))
  (factor-memo-labels (mapcar #'generate-labels-element 
			      memoized-labels-list) forms)))

--- NEW FILE: F-54A44C0786853024F450D715BBB3997E.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(require "mapping")
(require "chatter")
(require "restart")
(provide "move")

(defun source-check (expansion source)
  (let ((real (abstract-to-real-path source)))
    (when (path-prefix-equal *mcvs-dir* real)
       (error "source path ~a is in a reserved Meta-CVS area." real))
    (when (path-equal *this-dir* real)
       (error "cannot move the sandbox root directory."))
    (when (not expansion)
      (if (exists real)
	(error "~a is local, not versioned under Meta-CVS." real)
	(error "~a does not exist." real)))))

(defun simple-rename (filemap source dest-file)
  (let ((dir-expansion (mapping-extract-paths 
			 (mapping-prefix-matches filemap source))))
    (source-check dir-expansion source)
    (mapping-rename-files filemap dir-expansion source dest-file)))

(defun simple-move-to-dir (filemap source dest-dir)
  (let ((dir-expansion (mapping-extract-paths 
			 (mapping-prefix-matches filemap source))))
    (source-check dir-expansion source)
    (multiple-value-bind (base dir) (basename source)
      (if dir
	(if (path-equal dest-dir *this-dir*)
	  (mapping-rename-files filemap dir-expansion source base)
	  (mapping-rename-files filemap dir-expansion dir dest-dir))
	(mapping-rename-files filemap dir-expansion source
	  (canonicalize-path (path-cat dest-dir base)))))))

(defun move-guts (filemap sources destination)
  (let* ((two-args (null (second sources)))
	 (destination-trailing-slash (string= (char destination
						    (1- (length destination)))
					      *path-sep*))
	 (dest-real-path (abstract-to-real-path destination))
	 (destination-file-object (no-existence-error (stat dest-real-path)))
	 (destination-file-exists (or (mapping-lookup filemap destination)
				      (and destination-file-object
					   (not (directory-p 
						 destination-file-object)))))
	 (destination-dir-exists (and (not destination-file-exists)
				      (or (mapping-prefix-lookup filemap 
								 destination)
					  (directory-p destination-file-object)
					  destination-trailing-slash))))
    (if two-args
      (if destination-dir-exists
	(simple-move-to-dir filemap (first sources) destination)
	(simple-rename filemap (first sources) destination))
      (if destination-file-exists
	(error "cannot move multiple to ~a." destination)
	(let ((skipped-all t))
	  (dolist (source sources filemap)
	    (can-restart-here ("Skip ~a and continue renaming." source)
	      (setf filemap (simple-move-to-dir filemap source destination))
	      (setf skipped-all nil)))
	  (when skipped-all
	    (error "skipped all move sources."))
	  filemap)))))

(defun mcvs-move (args)
  (when (< (length args) 2)
    (error "requires at least two arguments."))
  (in-sandbox-root-dir
    (chatter-debug "Renaming.~%")
    (let ((filemap (mapping-read *mcvs-map*))
	  (sources (mapcar #'real-to-abstract-path 
			   (mapcar #'sandbox-translate-path (butlast args))))
	  (destination (canonicalize-path
			 (real-to-abstract-path 
			   (sandbox-translate-path (first (last args)))))))

      (let ((dest-real (abstract-to-real-path destination)))
	(when (path-prefix-equal *mcvs-dir* dest-real)
	  (error "destination path ~a is in a reserved Meta-CVS area." 
		 dest-real)))

      (let ((edited-filemap (move-guts filemap sources destination))
	    (restore-map t))
	(setf edited-filemap (sort edited-filemap
				   #'string< :key #'mapping-entry-id))
	(when (equal-filemaps edited-filemap filemap)
	  (error "useless move of an object onto itself"))

	;; In case a move clobbers some object that has local edits,
	;; we need to synchronize it to the MCVS directory.
	(chatter-debug "Synchronizing.~%")
	(mapping-synchronize :direction :left)

	(unwind-protect
	  (progn
	    (mapping-write edited-filemap *mcvs-map* :sort-map nil)
	    (chatter-debug "Updating file structure.~%")
	    (when (mapping-update)
	      (setf restore-map nil)))
	  (when restore-map
	    (chatter-terse "Undoing changes to map.~%")
	    (mapping-write filemap *mcvs-map*)))))
  (values)))

(defun mcvs-move-wrapper (cvs-options cvs-command-options mcvs-args)
  (declare (ignore cvs-options cvs-command-options))
  (mcvs-move mcvs-args))

(defconstant *move-help*
"Syntax:

  mcvs move objects ... destination

Options:

  none

Semantics:

  The move command changes the names of versioned objects, resulting in a local
  edit of the map. Like any other local change, a move is not published to the
  repository until it is committed.

  A move which affects the last component of a path is known as a rename; the
  object appears to stay in the same directory, but its name changes. A move
  affecting one or more of the other components appears to be a relocation.
  Both of these are the same thing to the software.

  The move command relocates only those files which are versioned in Meta-CVS;
  it does not act upon local files. However, files can be moved into local
  directories. Files can also be moved such that they clobber local files.

  The behavior of the command very convenient, obeying the following rules:

  - If the destination is an existing directory in the sandbox,
    then the pathnames of the objects are renamed such that the objects are
    relocated into that directory. If any of the source objects
    are directories, then they are moved.

  - If the destination is an existing file, then there must be exactly one
    source argument; two or more objects cannot be moved to a non-directory
    object. If that object is a local file, then the move produces an error,
    which can be interactively resolved in favor of clobbering the file.
    If the object is a Meta-CVS versioned file, then it is silently removed
    as if by the remove command (which means that it is not lost, merely
    unlinked from the map).

  - If the destination does not exist, then it is deemed to be a directory
    name if there are two or more source arguments, or to be a non-directory
    name if there is one source argument. In the first case, the directory
    is automatically created; there is no need for mkdir as with the Unix
    mv command, so this is a nice convenience.

  - If a move causes any directory to become empty, meaning that it contains
    no local files, or Meta-CVS versioned files, that directory is removed.
    This rule is applied recursively all the way up to the sandbox root: if
    removing a directory causes its parent to become empty, that parent is
    removed and so forth. Remember, empty directories have no representation
    in Meta-CVS, and this is another way in which this turns out to be
    a convenience. Directories that are not empty are not removed, even
    if they contain only local files not known to the version control system.
  
  - A directory can be moved into itself or to a subdirectory of itself.
    The reader is invited to experiment to see how this works. The Unix
    mv command disallows this, as does the underlying rename() system
    call, so this is a third convenience.

  - The root directory of a full or partial sandbox cannot be a source
    argument.")

--- NEW FILE: F-5B815906BE2D64E9BC2E48B76242BFF2.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(provide "sync")

(defun synchronize-files (left-file right-file should-be-executable
			  &key (direction :either))
"Ensure that the two files have the same contents, using any means,
including the possibility of making them hard links to the same object.
If they are already the same object, nothing happens and the symbol
:same is returned. Otherwise the newer one prevails, and clobbers the older
one; the symbols :left or :right are returned to indicate which prevailed. If
one of them doesn't exist, then it is created. If neither exists, nothing
happens, and NIL is returned. If either file is actually a directory, 
:dir is returned"
  (flet ((exec-check (file-info)
	   (if should-be-executable
	     (make-executable file-info)
	     (make-non-executable file-info))))
    (let ((left (exists left-file))
	  (right (exists right-file)))
      (cond
	((not (or left right)) 
	  nil)
	((or (directory-p left) (directory-p right))
	  :dir)
	((not right)
	  (honor-dry-run (left-file right-file)
	    (exec-check left)
	    (or (unless (eq direction :left)
		  (ensure-directories-exist right-file)
		  (link left-file right-file)
		  :left)
		:no-sync)))
	((not left)
	  (honor-dry-run (left-file right-file)
	    (exec-check right)
	    ;; Special case: do not re-create files missing in 
	    ;; CVS sandbox! Either someone tampered with the sandbox,
	    ;; in which case we just let CVS resurrect the file,
	    ;; and a subsequent sync will properly have the clean-copy
	    ;; semantics, propagating the clean copy to the tree.
	    ;; Or else CVS itself made the file disappear, in which 
	    ;; case if we restore it, CVS will later complain that the file
	    ;; is ``in the way''!
	    :no-sync))
	((same-file-p right left) 
	  (honor-dry-run (right-file)
	    (exec-check right))
	  :same)
	((older-p left right)
	  (honor-dry-run (left-file right-file)
	    (exec-check right)
	    (or (unless (eq direction :right)
		  (unlink left-file)
		  (link right-file left-file)
		  :right)
		:no-sync)))
	((older-p right left)
	  (honor-dry-run (left-file right-file)
	    (exec-check left)
	    (or (unless (eq direction :left)
		  (unlink right-file)
		  (link left-file right-file)
		  :left)
		:no-sync)))
	(t
	  (restart-case
	    (ecase direction
	      ((:right) (invoke-restart :choose-left))
	      ((:left) (invoke-restart :choose-right))
	      ((:either) (error "~a and ~a have the same modification time."
				left-file right-file)))
	    (:choose-left () :report (lambda (s)
				       (format s "take ~a; clobber ~a." 
					       left-file right-file))
	      (honor-dry-run (left-file right-file)
		(unlink right-file)
		(link left-file right-file)
		(exec-check left))
	      :left)
	    (:choose-right () :report (lambda (s)
					(format s "take ~a; clobber ~a." 
						right-file left-file))
	      (honor-dry-run (left-file right-file)
		(unlink left-file)
		(link right-file left-file)
		(exec-check right))
	      :right)))))))

--- NEW FILE: F-6763C87866B0E9BE56C154839D6FAB55.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(require "dirwalk")
(require "mapping")
(require "find-bind")

(defun mcvs-purge (global-options)
  (in-sandbox-root-dir
    (let* ((filemap (mapping-read *mcvs-map* :sanity-check t))
	   (to-be-removed (mapping-removed-files filemap)))
      (when to-be-removed
	(chdir *mcvs-dir*)
	 (chatter-debug "Invoking CVS.~%")
	 (unless (execute-program-xargs `("cvs" ,@(format-opt global-options)
					  "rm" "-f")
					(mapcar #'basename to-be-removed))
	   (error "CVS rm failed.")))))
  (values))

(defun mcvs-purge-wrapper (global-options command-options args)
  (declare (ignore command-options))
  (when args
    (error "no arguments permitted."))
  (mcvs-purge global-options))

--- NEW FILE: F-6C2D433380C1B1B204522582A4F30484.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(defmacro with-slot-refs ((&rest slot-entries) instance-form &body forms)
"A macro similar to with-slots, except that each occurence of any
of the bound variables newly evaluates instance-form."
  (let ((slot-macrolets
	  (mapcar #'(lambda (e)
		      (cond
			((consp e)
			   (when (or (not (= (length e) 2))
				     (not (symbolp (first e)))
				     (not (symbolp (second e))))
				 (error "with-slots-*: slot entry ~a must be two symbols." e))
			   `(,(first e) (slot-value ,instance-form ',(second e))))
			((symbolp e)
			   `(,e (slot-value ,instance-form ',e)))
			(t (error "with-slots-*: slot entry ~a must be a symbol." e))))
		  slot-entries)))
   `(symbol-macrolet ,slot-macrolets , at forms)))

(defmacro with-multi-slot-refs ((&rest refs) &body forms)
"Allows nested slot-shorthand invocations to be collapsed. That is:
  (with-slot-refs (E-1) I-1 ... ( ...  (with-slot-refs (E-N) I-N F) ... ) ...)
can be rewritten:
  (with-slot-refs-* ((E-1) I1 ... (E-N) V-N) F)"
 (let (refs-pairs (expansion forms))
   (do ((entries (pop refs) (pop refs))
	(instance (pop refs) (pop refs)))
       ((null entries))
       (push (list entries instance) refs-pairs))
   (if (null refs-pairs)
    `(progn , at expansion)
     (dolist (refs-pair refs-pairs (first expansion))
       (setf expansion `((with-slot-refs , at refs-pair , at expansion)))))))


--- NEW FILE: F-74915F0862B511AC9C233FDCB87DBEF8.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "dirwalk")
(require "chatter")
(require "mapping")
(require "options")
(require "generic")
(provide "update")

(defun mcvs-update (&optional cvs-options cvs-update-options files)
  (let ((need-sync (not (find "p" cvs-update-options 
			      :key #'first :test #'string=))))
    (if (or files *metaonly-option* *nometa-option*)
      (mcvs-generic "update" cvs-options cvs-update-options nil 
		    files :need-sync-after need-sync 
		    :need-update-after t)
      (in-sandbox-root-dir
	(if need-sync
	  (progn
	    ;; Push changes in tree to CVS sandbox, so they can be merged
	    ;; with stuff coming from repository.
	    (chatter-debug "Synchronizing.~%")
	    (mapping-synchronize :direction :left)

	    (current-dir-restore 
	      (chdir *mcvs-dir*) 
	      (super-restart-case
		(progn
		  (chatter-debug "Invoking CVS.~%")
		  (unless (execute-program `("cvs" ,@(format-opt cvs-options) 
					     "up" ,@(format-opt 
						      cvs-update-options)))
		    (error "CVS update failed.")))
		(continue () 
		  :report "Update file structure and re-synchronize." 
		  (unwind))
		(retry () 
		  :report "Try invoking CVS again." 
		  (retry))))

	    (chatter-debug "Updating file structure.~%")
	    (mapping-update)
	    (chatter-debug "Synchronizing again.~%")
	    (mapping-synchronize :direction :right))
	  (current-dir-restore 
	    (chdir *mcvs-dir*) 
	    (chatter-debug "Invoking CVS.~%")
	    (unless (execute-program `("cvs" ,@(format-opt cvs-options) 
				       "up" ,@(format-opt cvs-update-options))))
	      (error "CVS update failed."))))))
  (values))

(defun mcvs-update-wrapper (cvs-options cvs-command-options mcvs-args)
  (mcvs-update cvs-options cvs-command-options mcvs-args))

--- NEW FILE: F-7849808E8711BA9FBEB0917F33B12A79.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(provide "find-bind")

(defmacro vector-bind (vars vec &rest forms)
  (do ((i 0 (1+ i))
       (var vars (rest var))
       (list))
      ((null var) `(let ,(nreverse list) , at forms))
    (push `(,(first var) (aref ,vec ,i)) list)))

(defun find-bind-extract-vals (key-vec default-vec sequence
			       test-func key-func take-func
			       &key remainder-p)
"This is an internal function that performs the sequence processing 
that underlies the find-bind macro."
  (let ((unique '#:unique)
	(remainder))
    (macrolet ((process-item (item-place remainder-save-form)
		 `(let* ((item (funcall key-func ,item-place))
			 (match (position item key-vec 
					  :test (lambda (x y)
						  (cond
						    ((eq x unique) nil)
						    ((eq y unique) nil)
						    (t (funcall test-func 
								x y)))))))
		    (cond
		      (match
			 (setf (aref default-vec match) 
			       (funcall take-func ,item-place))
			 (setf (aref key-vec match) unique))
		      (t (when remainder-p ,remainder-save-form))))))
      (typecase sequence
	(list
	  (dolist (element sequence)
	    (process-item element (push element remainder)))
	  (setf remainder (nreverse remainder)))
	(vector
	  (setf remainder (make-array (list (length sequence)) :fill-pointer 0))
	  (dotimes (i (length sequence))
	    (process-item (aref sequence i)
			  (vector-push (aref sequence i) remainder))))
	(otherwise
	  (error "FIND-BIND: value ~s specified as SEQUENCE parameter.~%"
		 sequence))))
    (values default-vec remainder)))
    
(defmacro find-bind ((&key (test '#'eql) 
			   (key '#'values) 
			   (take '#'values))
		     (&optional remainder &rest var-specs)
		     sequence &body forms)
"Slick macro for binding variables to elements of a sequence
by matching keys.

Syntax:

  find-bind ({:test test-func} {:key key-func} {:take take-func})
	    ({rem-var} {(var key {default-value})}*) 
            sequence {decl}* {form}* 

Arguments:

  var               A symbol naming a variable to be bound.
  key               A value to be sought after in the input sequence.
  default-value     Optional value to bind to the variable if a match
                    is not found, or the variable would otherwise be
		    bound to the value NIL.
  rem-var           A symbol naming the variable to be bound to
                    a new sequence that has only the unmatched elements
		    from the original sequence.
  test-func         A dyadic comparison function, used to compare
                    elements from the input sequence. Default is #'eql.
  key-func          A monadic function, used to select what part of
                    the sequence elements to compare. Default is to
                    compare the elements themselves.
  take-func         A monadic function, specifies what part of elements
                    to bind to variables (other than rem-var). Default
                    is to take the entire element.
  sequence          The input sequence.

Semantics:

  The specified keys are looked up in the sequence and their corresponding
  variables are bound to the values that are found, or else to their
  default value, or NIL if there is no default value. If NIL happens
  to be the result of an explict match, the default value is substituted,
  if specified.

  The rem-var variable is bound to a new sequence that is stripped of
  these previously located elements. The declarations and forms are
  then evaluated in the lexical environment thus formed.

  The binding occurs left to right. The first occurence of a value
  name in the binding list matches the first occurence of the value
  name in the input sequence. A second occurence of the same value
  matches a second occurence and so on."
  (when (consp remainder)
    (push remainder var-specs)
    (setf remainder nil))
  (let ((vars (mapcar #'first var-specs))
	(keys (mapcar #'second var-specs))
	(defaults (mapcar #'third var-specs))
	(val-sym (gensym "VALS-"))
	(rem-sym (gensym "REM-")))
    `(multiple-value-bind (,val-sym ,rem-sym) 
			  (find-bind-extract-vals (vector , at keys) 
						  (vector , at defaults)
						  ,sequence 
						  ,test ,key ,take
						  :remainder-p 
						  ,(not (null remainder)))
       (declare (ignorable ,rem-sym))
       ,(if remainder
	 `(let ((,remainder ,rem-sym)) (vector-bind (, at vars) ,val-sym , at forms))
	 `(vector-bind (, at vars) ,val-sym , at forms)))))

--- NEW FILE: F-8E73F07FB339A6981C69AF06C278B49A.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "slot-refs")
(provide "rcs-utils")

(defstruct rcs-token
  (type)
  (lexeme))

(defstruct rcs-token-stream
  (stream)
  (pushback-stack))

(defgeneric rcs-read-token (stream))
(defgeneric rcs-peek-token (stream tok))

(defstruct rcs-admin
  (head)
  (branch)
  (access-list)
  (symbols)
  (locks)
  (locks-strict)
  (comment)
  (expand)
  (newphrases))

(defstruct rcs-delta
  (version)
  (date)
  (author)
  (state)
  (branches)
  (next)
  (newphrases))

(defstruct rcs-file
  (admin)
  (deltas)
  (delta-hash))

(defun rcs-special-p (ch)
  (or (char= ch #\$) (char= ch #\,) (char= ch #\.) 
      (char= ch #\;) (char= ch #\:) (char= ch #\@)))

(defun rcs-extract-id-sym-or-num (stream)
  (let (contains-dot contains-idchar)
    (let ((lexeme (with-output-to-string (ss)
		    (loop
		      (let ((ch (peek-char nil stream)))
			(cond
			  ((char= ch #\.)
			     (setf contains-dot t)
			     (write-char ch ss))
			  ((digit-char-p ch)
			     (write-char ch ss))
			  ((or (rcs-special-p ch) (char= ch #\space)
			     (not (graphic-char-p ch)))
			     (return))
			  (t (setf contains-idchar t)
			     (write-char ch ss)))
			(read-char stream))))))
    (make-rcs-token :type (cond
			    ((and contains-dot contains-idchar) :id)
			    (contains-idchar :sym)
			    (t :num))
		    :lexeme lexeme))))

(defun rcs-extract-string (stream)
  (read-char stream)
  (make-rcs-token
    :type :string
    :lexeme
    (with-output-to-string (ss)
      (let ((state :initial))
	(loop
	  (let ((ch (peek-char nil stream)))
	    (case state
	      ((:initial)
		 (if (char= ch #\@)
		   (setf state :atsign)
		   (write-char ch ss)))
	      (otherwise
		 (if (char= ch #\@)
		   (progn
		     (write-char ch ss)
		     (setf state :initial))
		   (return))))
	    (read-char stream)))))))

(defmethod rcs-read-token ((stream stream))
  (handler-bind ((end-of-file #'(lambda (condition) 
				  (declare (ignore condition))
				  (return-from rcs-read-token 
					       (load-time-value 
						 (make-rcs-token :type :eof
								 :lexeme ""))))))
    (loop
      (let ((ch (peek-char nil stream)))
	(cond
	  ((digit-char-p ch)
	     (return (rcs-extract-id-sym-or-num stream)))
	  ((char= ch #\@)
	     (return (rcs-extract-string stream)))
	  ((rcs-special-p ch) 
	     (read-char stream)
	     (return (make-rcs-token :type :special :lexeme ch)))
	  ((and (graphic-char-p ch) (not (char= ch #\space)))
	     (return (rcs-extract-id-sym-or-num stream)))
	  (t (read-char stream)))))))

(defmethod rcs-read-token ((stream t))
  (rcs-read-token *standard-input*))

(defmethod rcs-read-token ((rts rcs-token-stream))
  (with-slots (stream pushback-stack) rts
    (cond
      ((pop pushback-stack))
      (t (rcs-read-token stream)))))

(defmethod rcs-pushback-token ((rts rcs-token-stream) (tok rcs-token))
  (push tok (slot-value rts 'pushback-stack)))

(defun rcs-match-optional (stream type-match &optional lexeme-match)
  (let ((token (rcs-read-token stream)))
    (with-slots (type lexeme) token
      (cond
	((and lexeme-match
	      (not (and (eq type type-match) (string= lexeme lexeme-match))))
	   (rcs-pushback-token stream token)
	   nil)
	((not (eq type type-match))
	   (rcs-pushback-token stream token)
	   nil)
	(t token)))))

(defun rcs-match-token (stream type-match &optional lexeme-match)
  (let ((token (rcs-read-token stream)))
    (with-slots (type lexeme) token
      (if lexeme-match
	(when (not (and (eq type type-match) (string= lexeme lexeme-match)))
	  (error "rcs-parse: expecting token \"~a\" of type ~a, not \"~a\" of type ~a." 
		 lexeme-match type-match lexeme type))
	(when (not (eq type type-match))
	  (error "rcs-parse: expecting token of type ~a, not ~a." type-match type)))
      token)))

(defun rcs-parse-newphrases (stream)
  (let (token newphrases)
    (with-slot-refs (lexeme) token
      (loop
	(if (setf token (or (rcs-match-optional stream :sym)
			    (rcs-match-optional stream :id)))
	  (let ((phrase (list lexeme)))
	    (loop
	      (cond
		((setf token (or (rcs-match-optional stream :sym)
				 (rcs-match-optional stream :id)
				 (rcs-match-optional stream :num)
				 (rcs-match-optional stream :string)))
		   (push lexeme phrase))
		((setf token (rcs-match-optional stream :special))
		   (if (char= lexeme #\:)
		     (push lexeme phrase)
		     (progn
		       (rcs-pushback-token stream token)
		       (push (nreverse phrase) newphrases)
		       (return))))
		(t (push (nreverse phrase) newphrases)
		    (return))))
	    (rcs-match-token stream :special #\;))
	  (return))))
    (nreverse newphrases)))

(defun rcs-parse-admin (stream)
  (let ((admin (make-rcs-admin))
	token)
    (with-multi-slot-refs ((head branch access-list symbols locks locks-strict 
			    comment expand newphrases) admin
			   (lexeme) token)
      ;; head { num } ;
      (rcs-match-token stream :sym "head")
      (setf token (rcs-match-optional stream :num))
      (when token
	(setf head lexeme))
      (rcs-match-token stream :special #\;)

      ;; { branch { num } ; }
      (when (rcs-match-optional stream :sym "branch")
	(setf token (rcs-match-optional stream :num))
	(when token
	  (setf branch lexeme))
	(rcs-match-token stream :special #\;))

      ;; access { id } * ;
      (rcs-match-token stream :sym "access")
      (loop
	(setf token (or (rcs-match-optional stream :sym)
			(rcs-match-optional stream :id)))
	(if token
	  (push lexeme access-list)
	  (return)))
      (nreverse access-list)
      (rcs-match-token stream :special #\;)

      ;; symbols { sym : num }* ;
      (rcs-match-token stream :sym "symbols")
      (loop
	(setf token (rcs-match-optional stream :sym))
	(cond
	  (token
	     (let ((symbol lexeme))
	       (rcs-match-token stream :special #\:)
	       (setf token (rcs-match-token stream :num))
	       (push (list symbol lexeme) symbols)))
	  (t (return))))
      (nreverse symbols)
      (rcs-match-token stream :special #\;)

      ;; locks { id : num }* ; { strict ; }
      (rcs-match-token stream :sym "locks")
      (loop
	(setf token (or (rcs-match-optional stream :sym)
			(rcs-match-optional stream :id)))
	(cond
	  (token
	     (let ((symbol lexeme))
	       (rcs-match-token stream :special #\:)
	       (setf token (rcs-match-token stream :num))
	       (push (list symbol lexeme) locks)))
	  (t (return))))
      (nreverse locks)
      (rcs-match-token stream :special #\;)
      (when (rcs-match-optional stream :sym "strict")
	(setf locks-strict t)
	(rcs-match-token stream :special #\;))

      ;; { comment { string } ; }
      (when (rcs-match-optional stream :sym "comment")
	(setf token (rcs-match-optional stream :string))
	(when token
	  (setf comment lexeme))
	(rcs-match-token stream :special #\;))

      ;; { expand { string } ; }
      (when (rcs-match-optional stream :sym "expand")
	(setf token (rcs-match-optional stream :string))
	(when token
	  (setf expand lexeme))
	(rcs-match-token stream :special #\;))

      ;; { newphrase }*
      (setf newphrases (rcs-parse-newphrases stream))
      admin)))

(defun rcs-parse-delta (stream)
  (let ((delta (make-rcs-delta))
	token)
    (with-multi-slot-refs ((version date author state branches 
			    next newphrases) delta
			   (lexeme) token)
      ;; num
      (setf token (rcs-match-optional stream :num))
      (if (not token)
	(return-from rcs-parse-delta nil))

      (setf version lexeme)

      ;; date num ;
      (rcs-match-token stream :sym "date")
      (setf token (rcs-match-token stream :num))
      (setf date lexeme)
      (rcs-match-token stream :special #\;)

      ;; author id ;
      (rcs-match-token stream :sym "author")
      (setf token (or (rcs-match-optional stream :sym)
		      (rcs-match-token stream :id)))
      (setf author lexeme)
      (rcs-match-token stream :special #\;)

      ;; state { id } ;
      (rcs-match-token stream :sym "state")
      (setf token (or (rcs-match-optional stream :sym)
		      (rcs-match-optional stream :id)))
      (when token
	(setf state lexeme))
      (rcs-match-token stream :special #\;)

      ;; branches { num } * ;
      (rcs-match-token stream :sym "branches")
      (loop
	(let ((token (rcs-match-optional stream :num)))
	  (if token
	    (push lexeme branches)
	    (return (nreverse branches)))))
      (rcs-match-token stream :special #\;)

      ;; next { num } ;
      (rcs-match-token stream :sym "next")
      (setf token (rcs-match-optional stream :num))
      (when token
	(setf next lexeme))
      (rcs-match-token stream :special #\;)

      ;; { newphrase }*
      (when (not (rcs-match-optional stream :sym "desc"))
	(setf newphrases (rcs-parse-newphrases stream)))
      delta)))

(defun rcs-parse-deltas (stream)
  (let (deltas)
    (loop
      (let ((delta (rcs-parse-delta stream)))
	(if delta
	  (push delta deltas)
	  (return (nreverse deltas)))))))

(defun rcs-make-delta-hash (deltas)
  (let ((hash (make-hash-table :test #'equal)))
    (mapc #'(lambda (delta)
	      (setf (gethash (slot-value delta 'next) hash) delta))
	  deltas)
    hash))

(defun rcs-parse (stream)
  "Parse RCS file."
  (let ((token-stream (make-rcs-token-stream :stream stream)))
    ;; We currently just need the admin and delta sections.
    (let ((file (make-rcs-file :admin (rcs-parse-admin token-stream)
			       :deltas (rcs-parse-deltas token-stream))))
      (setf (slot-value file 'delta-hash) 
	    (rcs-make-delta-hash (slot-value file 'deltas)))
      file)))

--- NEW FILE: F-97770D7ED2DFF388BC60EAB380950A77.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(require "restart")
(provide "dirwalk")

;; TODO: this sucks, it should put out canonicalized path names
(defun dirwalk-fi (dir-fi func &rest keys &key norecurse postorder)
  (let ((dir-path (file-name dir-fi)))
    (setf dir-path (cond
		     ((string-equal dir-path "") 
		        #.(format nil "~a~a" *this-dir* *path-sep*))
		     ((eql (char dir-path (1- (length dir-path))) *path-sep*) 
		        dir-path)
		     (t (format nil "~a~a" dir-path *path-sep*))))
    (catch 'dirwalk-skip
      (when (not postorder)
        (funcall func dir-fi))
      (with-open-dir (d dir-path)
	(loop
	  (let ((name (readdir d)) entry-path fi)
	    (can-restart-here ("Continue processing directory ~a." dir-path)
	      (cond
		((null name) (return))
		((string-equal name *this-dir*) nil)
		((string-equal name *up-dir*) nil)
		((and (setf entry-path (format nil "~a~a" dir-path name))
		      (setf fi (stat entry-path))
		      nil))
		((and (not norecurse) (directory-p fi))
		 (apply #'dirwalk-fi fi func keys))
		(t (funcall func fi)))))))
      (when postorder
	(funcall func dir-fi)))))

(defun dirwalk (dir-path func &rest keys &key norecurse postorder)
  (declare (ignore norecurse postorder))
  (let ((fi (stat dir-path)))
     (if (directory-p fi)
       (apply #'dirwalk-fi fi func keys)
       (catch 'dirwalk-skip (funcall func fi)))))

(defun map-path (dir-path func)
  (dirwalk dir-path #'(lambda (x) (funcall func (file-name x)))))

(defmacro for-each-path ((var dirpath) &body forms)
  (let ((file-info (gensym "FILE-INFO-")))
   `(dirwalk ,dirpath #'(lambda (,file-info) 
			  (flet ((skip () (throw 'dirwalk-skip nil)))
			    (let ((,var (file-name ,file-info))) 
			      , at forms))))))

(defmacro for-each-file-info ((var dirpath &rest keys 
			       &key norecurse postorder) &body forms)
  (declare (ignore norecurse postorder))
   `(dirwalk ,dirpath #'(lambda (,var) 
			  (flet ((skip () (throw 'dirwalk-skip nil)))
			    , at forms)) , at keys))

(defun delete-recursive (dir-or-file)
  (for-each-file-info (fi dir-or-file :postorder t)
    (if (directory-p fi)
      (rmdir (file-name fi))
      (unlink (file-name fi)))))

(defun ensure-directories-gone (dir-or-file-to-erase)
"Intended as the inverse of Common Lisp's ensure-directories-exist, this
function erases the specified file. Then it tries to erase the parent
directory. If that succeeds, then it tries to erase the grandparent parent
directory and so on, until it encounters a directory that cannot be removed."
  (if (directory-p dir-or-file-to-erase)
    (rmdir dir-or-file-to-erase)
    (unlink dir-or-file-to-erase))

  (multiple-value-bind (base dir) (basename (canonicalize-path 
					     dir-or-file-to-erase))
    (declare (ignore base))
    (handler-case
      (loop
	(rmdir dir)
	(setf dir (canonicalize-path (path-cat dir *up-dir*))))
      (error (x) (declare (ignore x)) (values)))))

--- NEW FILE: F-9FD71CEB3A8045B747F54A629ED92A8D.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(require "mapping")
(require "chatter")
(require "find-bind")
(provide "remove")

(defun mcvs-remove (recursivep files &key no-sync)
  (when (null files)
    (return-from mcvs-remove (values)))

  (in-sandbox-root-dir
    (let (files-to-remove (filemap (mapping-read *mcvs-map*)))

      (chatter-debug "Unmapping.~%")
      (dolist (file files)
	(can-restart-here ("Continue unmapping files.")
	  (let* ((full-name (sandbox-translate-path file))
		 (abs-name (canonicalize-path 
			      (real-to-abstract-path full-name)))
	   	 (entries (mapping-prefix-matches filemap abs-name)))
	    (cond
	      ((path-prefix-equal *mcvs-dir* full-name)
		 (error "cannot remove ~a: path is in a reserved Meta-CVS area."
			full-name))
	      ((and (second entries) (not recursivep))
		 (error "cannot remove ~a: it is a directory, use -R to remove." 
			full-name))
	      ((not entries)
		 (if (exists full-name)
		   (error "cannot remove ~a: it is local, not versioned under Meta-CVS."
			  full-name)
		   (error "cannot remove ~a: it does not exist." full-name)))
	      (t (setf files-to-remove (nconc files-to-remove entries)))))))

      (when files-to-remove
	;; Removed files might have unsynchronized local edits, which
	;; will be irretrievably lost if we don't synchronize.
	;; But the grab command does not need this, hence no-sync option.
	(chatter-debug "Synchronizing.~%")
	(unless no-sync
	  (mapping-synchronize :direction :left))
	(let ((new-filemap (set-difference filemap files-to-remove 
			    		   :test #'mapping-same-id-p)))
	  (mapping-write new-filemap *mcvs-map* :sort-map t))

	(chatter-debug "Updating file structure.~%")
	(mapping-update :no-delete-removed no-sync))))
  (values))

(defun mcvs-remove-wrapper (cvs-options cvs-command-options mcvs-args)
  (declare (ignore cvs-options))
  (find-bind (:test #'string= :key #'first)
	     ((recursivep "R"))
	     cvs-command-options
    (mcvs-remove recursivep mcvs-args)))

(defconstant *remove-help*
"Syntax:

  mcvs remove [ options ] objects ...

Options:

  -R                Recursive behavior: recursively remove objects
                    in subdirectories. By default, trying to remove
                    a subdirectory signals a continuable error.

Semantics:

  The remove command removes objects from the mapping. To propagate
  the removal to the repository, a commit operation must be invoked.

  Removed files are not actually subject to a CVS-level erasure; they are
  merely removed from the map, but still exist in the MCVS subdirectory. Their
  local modifications are not lost. To actually remove files from CVS,
  use the purge command.  Removed files that have not been purged can be
  recovered via the restore command which re-creates mapping entries for them
  in the lost+found directory under machine-generated names; they can then be
  renamed to more appropriate names. Symbolic links cannot be restored;
  they exist as mapping entries only.")

--- NEW FILE: F-A30F4DBDE92A478CEB73EF64056E4340.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(require "dirwalk")
(require "mapping")

(defun mcvs-restore ()
  (in-sandbox-root-dir
    (let* ((filemap (mapping-read *mcvs-map* :sanity-check t))
	   (removed-files (mapping-removed-files filemap)))
      (dolist (removed removed-files)
	(push (make-mapping-entry :kind :file
				  :id removed
				  :path (path-cat (real-to-abstract-path 
						    "lost+found")
						  (basename removed))
				  :executable (executable-p removed))
	      filemap))
      (mapping-write filemap *mcvs-map* :sort-map t)
      (mapping-update))))

(defun mcvs-restore-wrapper (global-options command-options args)
  (declare (ignore global-options command-options))
  (when args
    (error "no arguments permitted."))
  (mcvs-restore))

--- NEW FILE: F-A3262E4C63ABCB9396F1C019B9CAE540.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "posix")
(provide "cmucl-unix")

;;; Base condition

(define-condition system-error (error) ((message :initarg :message :reader message))
  (:report (lambda (condition stream)
             (format stream "System error: ~A" 
	       (slot-value condition 'message)))))

;;; Macro to catch ENOENT errors and turn them into nil 
;;; return value.

(defmacro no-existence-error (&body forms)
  (let ((block-sym (gensym "BLOCK-")))
   `(block ,block-sym
     (handler-bind
       ((system-error #'(lambda (con)
			  (declare (ignore con))
			  (if (= unix:unix-errno unix:ENOENT)
			    (return-from ,block-sym nil)))))
	 , at forms))))

;;; Directory access

(define-condition open-dir-error (system-error) ((dir :initarg :dir)))

(defmethod initialize-instance :after ((c open-dir-error) &rest args)
  (declare (ignore args))
  (with-slots (dir message) c
    (setf message (format nil "Unable to open ~A: ~A." 
                          dir (aref unix::*unix-errors* (unix:unix-errno))))))

(define-condition open-error (system-error) ((path :initarg :path)))

(defmethod initialize-instance :after ((c open-error) &rest args)
  (declare (ignore args))
  (with-slots (path message) c
    (setf message (format nil "Unable to open ~A: ~A." 
                          path (aref unix::*unix-errors* (unix:unix-errno))))))
   
   
(defun opendir (dir) 
  (cond
    ((unix:open-dir dir))
    (t (error (make-condition 'open-dir-error :dir dir)))))

(declaim (inline closedir))
(defun closedir (dir-stream) 
  (when dir-stream (unix:close-dir dir-stream)))

(declaim (inline readdir))
(defun readdir (dir-stream) 
  (unix:read-dir dir-stream))


(defmacro with-open-dir ((var dir) &body forms)
 `(let ((,var (opendir ,dir)))
    (unwind-protect
      (progn , at forms)
      (closedir ,var))))

(define-condition chdir-error (system-error) ((dir :initarg :dir)))

(defmethod initialize-instance :after ((c chdir-error) &rest args)
  (declare (ignore args))
  (with-slots (dir message) c
    (setf message (format nil "Unable to change to directory ~A: ~A." 
                          dir (aref unix::*unix-errors* (unix:unix-errno))))))

(defun chdir (dir)
  (if (not (unix:unix-chdir dir))
    (error (make-condition 'chdir-error :dir dir)))
    (values))

(defmacro current-dir-restore (&body forms)
  (let ((saved-dir (gensym "SAVED-DIR-"))
        (getdir-ok (gensym "GETDIR-OK-")))
    `(multiple-value-bind (,getdir-ok ,saved-dir)
			  (unix:unix-current-directory)
       (when (not ,getdir-ok)
	 (error "could not determine current working directory"))
       (unwind-protect (progn , at forms)
                       (chdir ,saved-dir)))))
  
;;; File information

(define-condition file-info-error (system-error) ((file :initarg :file)))

(defmethod initialize-instance :after ((c file-info-error) &rest args)
  (declare (ignore args))
  (with-slots (file message) c
    (setf message (format nil "Unable to get status of ~A: ~A." 
                          file (aref unix::*unix-errors* (unix:unix-errno))))))

(defclass file-info ()
  ((file-name :initarg :file-name :accessor file-name)
   (mode-flags :initarg :mode-flags :accessor mode-flags)
   (mod-time :initarg :mod-time :accessor mod-time)
   (inode :initarg :inode :accessor inode)
   (num-links :initarg :num-links :accessor num-links)))

(defgeneric same-file-p (file1 file2))
(defgeneric older-p (file1 file2))
(defgeneric regular-p (file))
(defgeneric directory-p (file))
(defgeneric symlink-p (file))
(defgeneric is-root-p (file))
(defgeneric get-parent (file))

(defmethod same-file-p ((f1 file-info) (f2 file-info))
  (= (inode f1) (inode f2)))

(defmethod same-file-p ((f1 string) (f2 string))
  (= (stat f1) (stat f2)))

(defmethod older-p ((f1 file-info) (f2 file-info))
  (< (mod-time f1) (mod-time f2)))

(defmethod older-p ((f1 string) (f2 string))
  (older-p (stat f1) (stat f2)))

(defmethod regular-p ((file file-info))
  (not (zerop (logand unix:s-ifreg (mode-flags file)))))

(defmethod regular-p ((filename string))
  (regular-p (stat filename)))

(defmethod regular-p ((x null))
  nil)

(defmethod directory-p ((file file-info))
  (not (zerop (logand unix:s-ifdir (mode-flags file)))))

(defmethod directory-p ((filename string))
  (directory-p (stat filename)))

(defmethod directory-p ((x null))
  nil)

(defmethod symlink-p ((file file-info))
  (not (zerop (logand unix:s-iflnk (mode-flags file)))))

(defmethod symlink-p ((filename string))
  (symlink-p (stat filename)))

(defmethod symlink-p ((x null))
  nil)

(defmethod is-root-p ((file file-info))
  (and (directory-p file)
       (same-file-p file (stat (format nil "~a/.." (file-name file))))))

(defmethod is-root-p ((filename string))
  (is-root-p (stat filename)))

(defmethod get-parent ((file file-info))
  (stat (format nil "~a/.." (file-name file))))

(defmethod get-parent ((filename string))
  (stat (format nil "~a/.." filename)))

(defun stat (name &key through-link)
  (if (typep name 'file-info)
    name
    (multiple-value-bind (okay dev inode mode nlink owner group 
			  devnum size atime mtime ctime)
			 (if through-link 
			    (unix:unix-stat name)
			    (unix:unix-lstat name))
      (declare (ignore dev owner 
		       group devnum size atime ctime))
      (when (not okay)
	(error (make-condition 'file-info-error :file name)))
	  (make-instance 'file-info :file-name name
				    :mode-flags mode
				    :mod-time mtime
				    :inode inode
				    :num-links nlink))))

(defun exists (name &key through-link)
  (no-existence-error (stat name :through-link through-link)))

;;; Symbolic and hard links

(define-condition link-error (system-error) 
  ((from-path :initarg :from-path)
   (to-path :initarg :to-path)))

(defmethod initialize-instance :after ((c link-error) &rest args)
  (declare (ignore args))
  (with-slots (message from-path to-path) c
    (setf message (format nil "Unable to link ~A to ~A: ~A." 
                          from-path to-path
			  (aref unix::*unix-errors* (unix:unix-errno))))))

(defun link (from to)
  (if (unix:unix-link from to)
    (values)
    (error (make-condition 'link-error :from-path from :to-path to))))

;;; Directory removal

(define-condition rm-error (system-error) 
  ((path :initarg :path)))

(defmethod initialize-instance :after ((c rm-error) &rest args)
  (declare (ignore args))
  (with-slots (message path) c
    (setf message (format nil "Unable to remove ~A: ~A." 
                          path (aref unix::*unix-errors* (unix:unix-errno))))))

(defun rmdir (dir)
  (if (unix:unix-rmdir dir)
    (values)
    (error (make-condition 'rm-error :path dir))))

(defun unlink (file)
  (if (unix:unix-unlink file)
    (values)
    (error (make-condition 'rm-error :path file))))

;;; Coprocesses

(defconstant *shell-executable* "/bin/sh")

(defun shell-interpreter (command)
  (setf command (coerce command 'simple-string))
  (let ((pid (unix:unix-fork)))
    (cond
      ((< pid 0) ;; error
         (error "fork failed"))
      ((zerop pid) ;; child
         (unix:unix-execve *shell-executable* `(,*shell-executable*
						 "-c" ,command))
	 (unix:unix-exit 1))
      (t ; parent
	 (multiple-value-bind (pid-out event status) 
			      (extensions::wait3)
	   (and (= pid pid-out)
		(eq event :exited)
		(eq status 0)))))))

(defmacro with-input-from-program ((stream-var arg-list) &body forms)
 `(let* ((,stream-var (make-pipe-input-stream 
			(arglist-to-command-string ,arg-list))))
    (declare (dynamic-extent ,stream-var))
    (when ,stream-var
      (unwind-protect (progn , at forms) (close ,stream-var)))))

(defmacro with-output-to-program ((stream-var arg-list) &body forms)
 `(let* ((,stream-var (make-pipe-output-stream 
			(arglist-to-command-string ,arg-list))))
    (declare (dynamic-extent ,stream-var))
    (when ,stream-var
      (unwind-protect (progn , at forms) (close ,stream-var)))))

;;; GUID generation

(defun guid-gen ()
  (with-open-file (f "/dev/urandom" 
                   :direction :input 
		   :element-type '(unsigned-byte 128))
    (read-byte f)))

--- NEW FILE: F-A371BDB8A9CF854FE00C63C1264B1D99.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

;; Clear out requires for mcvs-upgrade to work right.
(setf *modules* nil)

(require "create")
(require "checkout")
(require "grab")
(require "add")
(require "remove")
(require "move")
(require "link")
(require "update")
(require "filt")
(require "generic")
(require "convert")
(require "branch")
(require "remap")
(require "purge")
(require "restore")
(require "prop")
(require "watch")
(require "split")
(require "restart")
(require "error")
(require "options")
(require "find-bind")
(provide "mcvs-main")

(define-option-constant *global-options* 
  (0 arg "H" "help" "Q" "q" "r" "w" "l" "n" "t" "v" "f" "version"
	 "meta" "metaonly" "nometa" "error-continue" "error-terminate" "debug")
  (1 arg "T" "e" "d" "r" "z" "s" "i" "up"))

(define-option-constant *help-options*)

(define-option-constant *create-options* 
  (0 arg "d")
  (1 arg "k" "I" "b" "m" "W"))

(define-option-constant *grab-options* 
  (0 arg "A") 
  (1 arg "r"))

(define-option-constant *checkout-options* 
  (0 arg "f") 
  (1 arg "r" "D" "d" "k" "j"))

(define-option-constant *export-options* 
  (0 arg "f") 
  (1 arg "r" "D" "d" "k"))

(define-option-constant *add-options* 
  (0 arg "R") 
  (1 arg "k" "m"))

(define-option-constant *remove-options* 
  (0 arg "R"))

(define-option-constant *update-options* 
  (0 arg "A" "C" "f" "p") 
  (1 arg "k" "r" "D" "j" "I" "W"))

(define-option-constant *switch-options* 
  (1 arg "k" "I" "W"))

(define-option-constant *commit-options* 
  (0 arg "f") 
  (1 arg "F" "m" "r"))

(define-option-constant *diff-options* 
  (0 arg "a" "b" "B" "brief" "c" "d" "e" "ed" "expand-tabs" "f" "forward-ed"
	 "H" "i" "ignore-all-space" "ignore-blank-lines" "ignore-case"
	 "ignore-space-change" "initial-tab" "l" "left-column" "minimal" "n"
	 "N" "new-file" "p" "P" "--paginate" "q" "rcs" "report-identical-files"
	 "s" "show-c-function" "side-by-side" "speed-large-files"
	 "suppress-common-lines" "t" "T" "text" "u" "unidirectional-new-file"
	 "w" "y") 
  (1 arg "C" "context" "D" "F" "horizon-lines" "ifdef" "ignore-matching-lines"
	 "L" "label" "line-format" "new-group-format" "new-line-format"
	 "old-group-format" "old-line-format" "r" "show-function-line"
	 "unchanged-group-format" "unchanged-line-format" "U" "unified" "W"
	 "width"))

(define-option-constant *tag-options* 
  (0 arg "l" "d" "f" "b" "F" "c") 
  (1 arg "r" "D"))

(define-option-constant *log-options* 
  (0 arg "R" "h" "t" "N" "b")
  (1 arg "r" "d" "s" "w"))

(define-option-constant *status-options* 
  (0 arg "v"))

(define-option-constant *annotate-options*
  (0 arg "f")
  (1 arg "r" "D"))

(define-option-constant *filt-options* 
  (1 arg "r" "D"))

(define-option-constant *remote-filt-options* 
  (1 arg "r" "D"))

(define-option-constant *move-options*)
(define-option-constant *link-options*)
(define-option-constant *convert-options*)
(define-option-constant *branch-options*)

(define-option-constant *merge-options*
  (1 arg "k"))

(define-option-constant *remerge-options*
  (1 arg "k"))

(define-option-constant *list-branches-options*)
(define-option-constant *remap-options*)
(define-option-constant *purge-options*)
(define-option-constant *restore-options*)

(define-option-constant *prop-options*
  (1 arg "set" "clear" "remove")
  (2 arg "value"))

(define-option-constant *watch-options*
  (0 arg "on" "off")
  (1 arg "add" "remove"))

(define-option-constant *watchers-options*)
(define-option-constant *edit-options*)
(define-option-constant *unedit-options*)
(define-option-constant *editors-options*)
(define-option-constant *sync-to-cvs-options*)
(define-option-constant *sync-from-cvs-options*)

(declaim (special *usage* *mcvs-command-table*))

(defun mcvs-help (global-options command-options args)
  (declare (ignore global-options command-options))
  (cond
    ((null args)
      (terpri)
      (write-line *usage*)
      (terpri))
    ((= (length args) 1)
      (let* ((command-name (first args))
	     (command (find command-name *mcvs-command-table* 
			    :key #'first
			    :test #'string=)))
	(when (null command)
	  (error "~a is not a recognized mcvs command." 
		 command-name))
	(let ((help-text (third command)))
	  (when (null help-text)
	    (error "sorry, no help available for ~a command."
		   command-name))
	  (terpri)
	  (write-line help-text)
	  (terpri))))
    (t (error "try \"mcvs help <name-of-command>\"."))))

(defconstant *mcvs-command-table*
 `(("help" ,#'mcvs-help nil ,*help-options*)
   ("create" ,#'mcvs-create-wrapper ,*create-help* ,*create-options*)
   ("grab" ,#'mcvs-grab-wrapper ,*grab-help* ,*grab-options*)
   ("checkout" ,#'mcvs-checkout-wrapper ,*checkout-help* ,*checkout-options*)
   ("co" ,#'mcvs-checkout-wrapper ,*checkout-help* ,*checkout-options*)
   ("export" ,#'mcvs-export-wrapper ,*export-help* ,*export-options*)
   ("ex" ,#'mcvs-export-wrapper ,*export-help* ,*export-options*)
   ("add" ,#'mcvs-add-wrapper ,*add-help* ,*add-options*)
   ("remove" ,#'mcvs-remove-wrapper ,*remove-help* ,*remove-options*)
   ("rm" ,#'mcvs-remove-wrapper ,*remove-help* ,*remove-options*)
   ("move" ,#'mcvs-move-wrapper ,*move-help* ,*move-options*)
   ("mv" ,#'mcvs-move-wrapper ,*move-help* ,*move-options*)
   ("link" ,#'mcvs-link-wrapper ,*link-help* ,*link-options*)
   ("ln" ,#'mcvs-link-wrapper ,*link-help* ,*link-options*)
   ("update" ,#'mcvs-update-wrapper nil ,*update-options*)
   ("up" ,#'mcvs-update-wrapper nil ,*update-options*)
   ("commit" ,#'mcvs-commit-wrapper nil ,*commit-options*)
   ("ci" ,#'mcvs-commit-wrapper nil ,*commit-options*)
   ("diff" ,#'mcvs-diff-wrapper nil ,*diff-options*)
   ("tag" ,#'mcvs-tag-wrapper nil ,*tag-options*)
   ("log" ,#'mcvs-log-wrapper nil ,*log-options*)
   ("status" ,#'mcvs-status-wrapper nil ,*status-options*)
   ("stat" ,#'mcvs-status-wrapper nil ,*status-options*)
   ("annotate" ,#'mcvs-annotate-wrapper nil ,*annotate-options*)
   ("filt" ,#'mcvs-filt-wrapper nil ,*filt-options*)
   ("fi" ,#'mcvs-filt-wrapper nil ,*filt-options*)
   ("remote-filt" ,#'mcvs-remote-filt-wrapper nil ,*remote-filt-options*)
   ("rfilt" ,#'mcvs-remote-filt-wrapper nil ,*remote-filt-options*)
   ("rfi" ,#'mcvs-remote-filt-wrapper nil ,*remote-filt-options*)
   ("convert" ,#'mcvs-convert-wrapper ,*convert-help* ,*convert-options*)
   ("branch" ,#'mcvs-branch-wrapper ,*branch-help* ,*branch-options*)
   ("switch" ,#'mcvs-switch-wrapper nil ,*switch-options*)
   ("sw" ,#'mcvs-switch-wrapper nil ,*switch-options*)
   ("merge" ,#'mcvs-merge-wrapper nil ,*merge-options*)
   ("remerge" ,#'mcvs-remerge-wrapper nil ,*remerge-options*)
   ("list-branches" ,#'mcvs-list-branches-wrapper nil ,*list-branches-options*)
   ("lb" ,#'mcvs-list-branches-wrapper nil ,*list-branches-options*)
   ("purge" ,#'mcvs-purge-wrapper nil ,*purge-options*)
   ("restore" ,#'mcvs-restore-wrapper nil ,*restore-options*)
   ("remap" ,#'mcvs-remap-wrapper nil ,*remap-options*)
   ("prop" ,#'mcvs-prop-wrapper nil ,*prop-options*)
   ("watch" ,#'mcvs-watch-wrapper nil ,*watch-options*)
   ("watchers" ,#'mcvs-watchers-wrapper nil ,*watchers-options*)
   ("edit" ,#'mcvs-edit-wrapper nil ,*edit-options*)
   ("unedit" ,#'mcvs-unedit-wrapper nil ,*unedit-options*)
   ("editors" ,#'mcvs-editors-wrapper nil ,*editors-options*)
   ("sync-from-cvs" ,#'mcvs-sync-from-wrapper nil ,*editors-options*)
   ("sync-to-cvs" ,#'mcvs-sync-to-wrapper nil ,*editors-options*)))

(defconstant *usage*
"Meta-CVS command syntax:

  mcvs [ global-options ] command [ command-options ] [ command-arguments ]

Global options:

  -H --help          Print this help and terminate. If a command is specified,
                     help specific to that command is printed instead.
  -Q                 Very quiet, generate output only for serious problems. (*)
  -q                 Somewhat quiet, some info messages suppressed. (*)
  -n                 Dry run; do not modify filesystem. (*)
  --debug            Verbose debug output; -Q and -q are ignored but still
                     passed to CVS.
  -r                 Make working files read-only. (@)
  -w                 Make new working files read-write (default). (@)
  -l                 Do not log cvs command in command history, but execute
                     it anyway. (@)
  -t                 Trace CVS execution. (@)
  -v --version       Display version information and terminate.
  -f                 CVS not to read ~/.cvsrc file. (@)
  -i script-name     Load a Lisp file and evaluate its top level forms,
                     allowing Meta-CVS to behave as an interpreter.
  --meta             Include metafiles such as MCVS/MAP in the set of files
                     to operate on.
  --metaonly         Operate only on metafiles.
  --nometa           Exclude metafiles from the set of files to operate on.
  --error-continue   Instead of interactive error handling, automatically 
                     continue all continuable errors.
  --error-terminate  Terminate with cleanup when an error happens instead
                     of interactive error handling.
  -T tempdir         Place temporary files in tempdir. (@)
  -e editor          Edit messages with editor. (*)
  -d root            Specify CVSROOT. (@)
  -z gzip-level      Specify compression level. (@)
  --up N             Escape out of N levels of sandbox nesting before executing
                     operation.

  Notes: (*) option processed by Meta-CVS and passed to CVS too.
         (@) option merely passed to CVS.

Commands:

  help               Obtain more detailed help for a specific command.
  create             Create new project from an existing file tree.
  grab               Take a snapshot of an external source tree, such
                     as a third-party release, and incorporate it into
                     the working copy. Tries to discover file moves.
  checkout (co)      Retrieve a Meta-CVS project from the repository to
                     create a working copy.
  export (ex)        Retrieve a Meta-CVS project without creating a 
                     working copy.
  add                Place files (or directories with add -R) under
                     version control.
  remove (rm)        Remove files or directories.
  move (mv)          Rename files and directories.
  link (ln)          Create a versioned symbolic link.
  update (up)        Incorporate latest changes from repository into 
                     working copy. 
  commit (ci)        Incorporate outstanding changes in the working copy
                     into the repository.
  diff               Compute differences between files in the working copy
                     and the repository or between revisions in the repository.
  tag                Associate a symbolic name with file revisions to create
                     an identifiable baseline.  By default, tags the
                     revisions that were last synchronized with the
                     directory. Note: tag -b creates a CVS branch,
                     it won't be a Meta-CVS branch with managed merges.
                     Consider the branch command instead!
  log                Display log information for files.
  status (stat)      Show current status of files.
  annotate           Perform a detailed analysis of files, showing the 
                     version information about every individual line of text.
  filt (fi)          Act as a text filter, which converts Meta-CVS F- file 
                     names to readable paths, according to the current mapping.
  remote-filt (rfi)  Remote version of filt, requires module name.
  branch             Create a managed branch. Meta-CVS managed branches keep 
                     track of what has been merged where, so users don't have
                     to track merges with tags at all.
  merge              Merge a managed branch to the current branch or trunk.
  remerge            Re-apply the most recent merge without changing any tags.
                     Useful when a merge goes bad so the local changes have
                     to be discarded and the merge done over again.
  list-branches (lb) List Meta-CVS managed branches.
  switch (sw)        Switch to a branch. With no arguments, switch to 
                     main trunk.
  remap              Force Meta-CVS to notice and incorporate moves and
                     deletions that were performed directly on the sandbox.
  purge              Execute a CVS remove on files that have been unmapped
                     with the remove command.
  restore            Restore files that have been deleted with the remove
                     command, but not purged. These appear in the lost+found
                     directory under cryptic names.
  prop               Manipulate properties.
                       prop --set <bool-prop-name> [ files ... ]
                       prop --clear <bool-prop-name> [ files ... ]
                       prop --value <prop-name> <new-value> [ files ... ]
                       prop --remove <prop-name> [ files ... ]
                     The ``exec'' property represents the execute permission
                     of a file.  More than one --set, --clear, --value 
                     or --remove may be specified before the files.
  watch              Manipulate per-file CVS watch settings.
                       watch --on [ files ... ]
                       watch --off [ files ... ]
                       watch --add <action> [ files ... ]
                       watch --remove <action> [ files ... ]
  watchers           See who is watching files.
  edit               Indicate the intent to edit a watched file.
  unedit             Retract the indication signaled by edit.
  editors            See who is editing files.
  sync-to-cvs        Synchronize tree in the direction of the CVS sandbox.
                     Useful when extending Meta-CVS with external scripts.
  sync-from-cvs      Synchronize CVS sandbox to the tree.
  convert            Convert a CVS module to a Meta-CVS project.
                     This requires direct filesystem access to the repository.
                     Caveat: this is a very blunt instrument.")

(defmacro with-open-file-ignore-errors ((var &rest open-args) &body forms)
  `(let ((,var (ignore-errors (open , at open-args))))
     (unwind-protect
       (progn , at forms)
       (when ,var (close ,var)))))

(defun mcvs-execute (args)
  (with-open-file-ignore-errors (*interactive-error-io* (parse-posix-namestring 
							  (unix-funcs:ctermid))
							:direction :io
							:if-does-not-exist nil)
    (let ((*mcvs-error-treatment* (if *interactive-error-io*
				    :interactive
				    :terminate)))
      (unless *interactive-error-io*
	(chatter-info "unable to open terminal device ~a .~%" 
		      (unix-funcs:ctermid))
	(chatter-info "interactive error handling disabled.~%"))
      (handler-bind ((error #'mcvs-error-handler))
	(multiple-value-bind (global-options global-args)
			     (parse-opt args *global-options*)
	  (setf global-options (filter-global-options global-options))

	  (when *print-usage*
	    (terpri)
	    (write-line *usage*)
	    (terpri)
	    (throw 'mcvs-terminate nil))

	  (when (not (first global-args))
	    (write-line "Meta-CVS requires a command argument." *error-output*)
	    (write-line "Use mcvs -H to view help." *error-output*)
	    (throw 'mcvs-terminate nil))

	  (let ((command (find (first global-args) *mcvs-command-table* 
			       :key #'first
			       :test #'string=)))
	    (when (not command)
	      (error "~a is not a recognized mcvs command." 
		     (first global-args)))
	    (destructuring-bind (name func help-text opt-spec) command
	      (declare (ignore name help-text))
	      (multiple-value-bind (command-options command-args)
				   (parse-opt (rest global-args) opt-spec)
		(funcall func global-options command-options command-args)))))))
    nil))

(defun mcvs-debug-shell ()
  (let ((counter 0)
        (*mcvs-error-treatment* :decline))
    (loop
      (format t "~&mcvs[~a]> " (incf counter))
      (let ((line (string-trim #(#\space #\tab) (read-line))))
	(restart-case
	  (cond
	    ((zerop (length line)))
	    ((string-equal line "exit")
	       (return-from mcvs-debug-shell))
	    ((char-equal (char line 0) #\!)
	       (print (eval (read-from-string (subseq line 1)))))
	    (t (mcvs-execute (split-words line #(#\space #\tab)))))
	  (debug () :report "Return to mcvs debug shell"
	    (terpri)))))))

#+clisp
(defun mcvs ()
  (exit (catch 'mcvs-terminate (or (mcvs-execute ext:*args*)
				   *mcvs-errors-occured-p*))))

--- NEW FILE: F-A580617EC4FE7BAAC13B25642EF48CAC.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(require "mapping")
(require "chatter")
(require "dirwalk")
(require "seqfuncs")
(require "options")
(require "types")
(provide "add")

(defun mcvs-add (recursivep cvs-options add-options files)
  (in-sandbox-root-dir
    (let* ((filemap (mapping-read *mcvs-map*))
	   (saved-filemap (copy-list filemap))
	   (types-exists (exists *mcvs-types*))
	   (types (and types-exists (types-read *mcvs-types*)))
	   new-map-entries new-types)

      (chatter-debug "Mapping.~%")

      (dolist (file files)
	(let (expanded-paths)
	  (can-restart-here ("Continue processing arguments after ~a." file)
	    (if recursivep 
	      (for-each-path (full-name (sandbox-translate-path file))
		(push (canonicalize-path full-name) expanded-paths))
	      (push (sandbox-translate-path file) expanded-paths)))
	  (nreverse expanded-paths)

	  (dolist (full-name expanded-paths)
	    (can-restart-here ("Continue mapping files.")
	      (let ((abs-name (real-to-abstract-path full-name))
		    (file-info (stat full-name)))
		(cond
		  ((path-prefix-equal *mcvs-dir* full-name)
		    (error "cannot add ~a: path is in a reserved Meta-CVS area."
			   full-name))
		  ((mapping-lookup filemap abs-name)
		    (chatter-info "~a already added.~%" full-name))
		  ((directory-p file-info)
		    (when (not recursivep)
		      (error "cannot add ~a: it is a directory, use -R to add." full-name)))
		  ((regular-p file-info)
		    (let* ((suffix (suffix full-name))
			   (f-file (mapping-generate-id :suffix suffix)))
		      (when suffix
			    (setf new-types (adjoin (list suffix :default) 
						    new-types :test #'equal)))
		      (push (make-mapping-entry :kind :file
						:id f-file
						:path abs-name
						:executable (executable-p 
							      file-info))
			    new-map-entries)))
		  ((symlink-p file-info)
		    (let ((id (mapping-generate-id :no-dir t :prefix "S-")))
		      (push (make-mapping-entry :kind :symlink
						:id id
						:path abs-name
						:target (readlink full-name))
			    new-map-entries)))
		  (t
		    (error "cannot add ~a: not regular file or symlink." 
			   full-name))))))))

      (setf new-types (set-difference 
			new-types types :key #'first :test #'string=))

      (let ((*dry-run-option* nil))
	(unwind-protect
	  (setf new-types (types-let-user-edit new-types *mcvs-new-types*))
	  (ignore-errors (unlink *mcvs-new-types*))))

      (setf new-map-entries (types-remove-ignores new-types new-map-entries))
      (setf new-map-entries (types-remove-ignores types new-map-entries))

      (when new-map-entries
	(dolist (map-entry new-map-entries)
	  (with-slots (kind id path) map-entry
	    (push map-entry filemap)
	    (let ((real-name (abstract-to-real-path path)))
	      (chatter-info "mapping ~a <- ~a~%" id real-name)
	      (if (eq kind :file)
		(link real-name id)))))

	(mapping-write filemap *mcvs-map* :sort-map t)

	(when (setf types (append types new-types))
	  (types-write types *mcvs-types*))

	(setf new-map-entries (mapping-extract-kind new-map-entries :file))

	(let ((add-commands (types-make-cvs-adds types new-map-entries))
	      (restore-needed t))
	  (unwind-protect
	    (loop
	      (restart-case 
		(current-dir-restore 
		  (chdir *mcvs-dir*) 
		  (chatter-debug "Invoking CVS.~%")
		  (dolist (add-args add-commands)
		    (when (not (execute-program `("cvs" ,@(format-opt cvs-options)
						  "add" ,@(format-opt add-options)
						  , at add-args)))
		      (error "CVS add failed.")))
		  (when (and types (not types-exists) (not *dry-run-option*))
		    (when (not (execute-program `("cvs" ,@(format-opt cvs-options)
						  "add" ,*mcvs-types-name*)))
		      (error "CVS add failed.")))
		  (setf restore-needed nil)
		  (return))
		(retry () 
		  :report "Try invoking CVS again.")))
	    (when restore-needed
	      (chatter-terse "Undoing changes to map.~%")
	      (mapping-write saved-filemap *mcvs-map*)
	      (ignore-errors
		(dolist (entry new-map-entries)
		  (unlink (mapping-entry-id entry)))))))

	(chatter-debug "Updating file structure.~%")
	(mapping-update))))
  (values))

(defun mcvs-add-wrapper (cvs-options cvs-command-options mcvs-args)
  (multiple-value-bind (recursivep rest-add-options) 
		       (separate "R" cvs-command-options 
				     :key #'first :test #'string=)
    (mcvs-add recursivep cvs-options rest-add-options mcvs-args)))

(defconstant *add-help*
"Syntax:

  mcvs add [ options ] objects ...

Options:

  -R                Recursive behavior: recursively add the contents
                    of all objects that are directories. By default,
                    trying to add a directory signals a continuable error.
  -m \"text ...\"     Use the specified text for the creation message.
  -k key-expansion  Add the file with the specified RCS expansion mode.

Semantics:

  The add command brings local filesystem objects under version control.
  The changes are not immediately incorporated into the repository; rather,
  the addition a local change that is ``scheduled'' until the next commit
  operation.
  
  Objects that can be added are files and symbolic links. Directories are not
  versioned objects in Meta-CVS; instead, files and symbolic links have a
  pathname property which gives rise to the existence of directories in the
  sandbox. The only significant consequence of this design choice is that empty
  directories have no direct representation in Meta-CVS.

  If any added files have suffixes that were not previously added to the
  project before, Meta-CVS will pop up a text editor to allow you to edit
  a specification that assigns to each new file type its CVS expansion
  mode.")

--- NEW FILE: F-C25BFAA9CFD16915F31BF90D03646B52.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(require "mapping")
(require "chatter")
(provide "link")

(defun mcvs-link (target name)
  (when (or (string= "" target)
	    (string= "" name))
    (error "empty path names are invalid."))
  (in-sandbox-root-dir
    (let* ((mapping (mapping-read *mcvs-map*))
	   (real-name (sandbox-translate-path name))
	   (abs-name (real-to-abstract-path real-name))
	   (trailing-slash (string= (char name (1- (length name))) *path-sep*))
	   (file-info (no-existence-error (stat real-name)))
	   (in-map (mapping-lookup mapping abs-name))
	   (prefix-in-map (mapping-prefix-lookup mapping abs-name))
	   (is-non-dir (or in-map (and file-info (not (directory-p file-info)))))
	   (is-dir (and (not is-non-dir)
			(or prefix-in-map (directory-p file-info) trailing-slash)))
	   (need-new-entry t))
      (when (path-prefix-equal *mcvs-dir* abs-name)
	 (error "path ~a is in a reserved Meta-CVS area." abs-name))

      ;; In case a link clobbers some object that has local edits,
      ;; we need to synchronize it to the MCVS directory.
      (chatter-debug "Synchronizing.~%")
      (mapping-synchronize :direction :left)

      (flet ((edit-map (entry)
	       (with-slots (path kind (tgt target)) entry
		 (chatter-debug "Clobbering existing object ~a.~%" path)
		 (unlink (abstract-to-real-path path))
		 (cond
		   ((eq kind :symlink)
		      (chatter-debug "Editing existing link.~%")
		      (setf tgt target)
		      (setf need-new-entry nil)
		      (symlink target (abstract-to-real-path path)))
		   (t (setf mapping
			    (remove entry mapping 
				    :test #'eq))))))
	     (make-new-entry (abs-name)
	       (when need-new-entry
		 (chatter-debug "Making new symlink entry ~a.~%" abs-name)
		 (push (make-mapping-entry :kind :symlink
					   :id (mapping-generate-id :no-dir t :prefix "S-")
					   :path abs-name
					   :target target)
		       mapping))))

	(cond
	  (in-map 
	     (edit-map in-map)
	     (make-new-entry abs-name))
	  (is-dir
	     (let* ((base (basename target))
		    (real-name (canonicalize-path (path-cat real-name base)))
		    (abs-name (canonicalize-path (path-cat abs-name base)))
		    (name (path-cat name base))
		    (file-info (no-existence-error (stat real-name)))
		    (in-map (mapping-lookup mapping abs-name))
		    (prefix-in-map (mapping-prefix-lookup mapping abs-name))
		    (is-non-dir (or in-map (and file-info (not (directory-p file-info)))))
		    (is-dir (and (not is-non-dir)
				 (or prefix-in-map (directory-p file-info)))))
	       (when is-dir
		  (error "~a is a directory." name))
	       (when in-map
		 (edit-map in-map))
	       (make-new-entry abs-name)))
	  (t (make-new-entry abs-name))))
      (mapping-write mapping *mcvs-map* :sort-map t)
      (chatter-debug "Updating file structure.~%")
      (mapping-update)))
  (values))

(defun mcvs-link-wrapper (global-options command-options args)
  (declare (ignore global-options command-options))
  (when (/= (length args) 2)
    (error "specify link target and link name."))
  (mcvs-link (first args) (second args)))

(defconstant *link-help*
"Syntax:

  mcvs link target-path name

Semantics:

  Create a symbolic link with the given name, containing the target path.
  Note the braindamaged reverse syntax, which is deliberately consistent
  with the Unix ``ln'' command. To make the symbolic link @foo -> bar,
  use ``mcvs ln bar foo''.

  Another way to add links is to create a symlink, and then use the add
  command.")

--- NEW FILE: F-C534B6E74FE1BD1E409FAAFBB6DC110B.sh ---
#!/bin/sh

CLISP_LIB=$(clisp -q -norc -x '(progn (princ *lib-directory*) (values))')

LINKSET=unix-bindings-linking-set

if [ $# != 1 ] ; then
  echo
  echo "Meta-CVS Installer"
  echo
  echo "Please specify the target prefix, as a full absolute path."
  echo "For example, specifying /usr/local will place files under"
  echo "/usr/local/bin and /usr/local/lib."
  echo
  exit 1
else
  TARGET="$1"
fi

space_check()
{
  if [ $# -gt 1 ] ; then 
    echo "The path \"$*\" contains whitespace."
    exit 1
  fi
}

dash_check()
{
  case $1 in 
    -* )
      echo "The path $1 looks like a command line option."
      exit 1
      ;;
  esac
}

space_check $TARGET
dash_check $TARGET

TARGET_LIB=$TARGET/lib/clisp/meta-cvs
TARGET_BIN=$TARGET/bin

if ! mkdir -p $TARGET_LIB ; then
  echo "Unable to create $TARGET_LIB directory."
  exit 1
fi

if ! mkdir -p $TARGET_BIN ; then
  echo "Unable to create $TARGET_BIN directory."
  exit 1
fi

if [ ! -e $LINKSET ] ; then
    export CLISP_LINKKIT="${CLISP_LIB}linkkit"
    sh "${CLISP_LIB}clisp-link" add-module-set unix-bindings \
    "${CLISP_LIB}base" $LINKSET
fi

LISPRUN=$LINKSET/lisp

if [ -f $LISPRUN.run ] ; then
  LISPRUN=$LISPRUN.run
  LISPEXE=.run
elif [ -f $LISPRUN.exe ] ; then
  LISPRUN=$LISPRUN.exe
  LISPEXE=.exe
else
  echo "linking set failed to build."
  exit 1
fi

if ! $LISPRUN -M $LINKSET/lispinit.mem -q -c mcvs-main ; then
  echo "There were compilation errors."
  exit 1
fi

$LISPRUN -M $LINKSET/lispinit.mem -q -i mcvs-main -x '(ext:saveinitmem "mcvs.mem" :quiet t)'

if ! cp mcvs.mem $TARGET_LIB/lispinit.mem; then
  echo "Unable to copy to $TARGET_LIB."
  exit 1
fi

if ! cp $LISPRUN $TARGET_LIB; then
  echo "Unable to copy to $TARGET_LIB."
  exit 1
fi

if ! cat > $TARGET_BIN/mcvs <<END
#!$TARGET_LIB/lisp$LISPEXE -M$TARGET_LIB/lispinit.mem
(mcvs)
END
then
  echo "Could not create mcvs script in $TARGET."
  exit 1
fi

if ! chmod a+x "$TARGET_BIN/mcvs" ; then
  echo "Could not set permissions of mcvs script in $TARGET."
  exit 1
fi

if ! cat > $TARGET_BIN/mcvs-upgrade <<END
#!/bin/sh
TARGET_LIB="$TARGET_LIB"
LISPRUN="\$TARGET_LIB/lisp.run -M \$TARGET_LIB/lispinit.mem"

if [ \$# != 1 ] ; then
  echo
  echo "Syntax:"
  echo
  echo "  mcvs-upgrade <path-to-source>"
  echo
  echo "The path specifies the directory which holds unpacked Meta-CVS source,"
  echo "the place where the file mcvs-main.lisp is located."
  echo
  echo "This upgrade mechanism is intended to make it possible to use a"
  echo "newer version of Meta-CVS without having to obtain a complete binary"
  echo "distribution that includes the Lisp executable, and without having"
  echo "to install the Lisp development environment to build the sources."
  echo
  echo "Note that it's not possible to upgrade if the newer Meta-CVS sources"
  echo "rely on new C functions being linked into the Lisp system; get a"
  echo "new binary distribution, or set up CLISP and compile Meta-CVS from"
  echo "the sources using its install.sh script"
  echo
  echo "Ignore the copious compiler warnings about objects and functions"
  echo "being redefined; this is what we want."
  echo
  exit 1
fi

SOURCE_PATH="\$1"

if ! cd "\$SOURCE_PATH" ; then
  echo "unable to change to \$SOURCE_PATH"
  exit 1
fi

if ! \$LISPRUN -c mcvs-main ; then
  echo "unable to compile"
  exit 1
fi

if ! \$LISPRUN -q -i mcvs-main -x '(ext:saveinitmem "mcvs.mem" :quiet t)' ; then
  echo "unable to load and generate memory image"
  exit 1
fi

if ! cp mcvs.mem \$TARGET_LIB/lispinit.mem ; then
  echo "unable to copy new Meta-CVS image to \$TARGET_LIB directory."
  exit 1
fi

echo
echo "It appears that Meta-CVS has been re-generated from the given sources."
echo 

END
then
  echo "Could not create mcvs script in $TARGET."
  exit 1
fi

if ! chmod a+x "$TARGET_BIN/mcvs-upgrade" ; then
  echo "Could not set permissions of mcvs script in $TARGET."
  exit 1
fi

exit 0

--- NEW FILE: F-CA4E16937768388DD32FAD6ADA8B6A2F.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "chatter")
(provide "clisp-unix")

;;; Null pointer handling

#.(when (< (first (system::version)) 20020129)
    (push :clisp-old *features*)
    (values))

#+clisp-old
  (defmacro pointer-null (p) `(unix-funcs:null-pointer-p ,p))

#-clisp-old
  (defmacro pointer-null (p) `(ffi:foreign-address-null ,p))

(defmacro null-to-nil (p) 
  (let ((pointer (gensym)))
    `(let ((,pointer ,p)) (if (pointer-null ,pointer) nil ,pointer))))

(defmacro when-not-null (p &body forms)
  `(if (not (pointer-null ,p)) , at forms))

;;; Base condition

(define-condition system-error (error) ((message :initarg :message))
  (:report (lambda (condition stream)
             (format stream "System error: ~A" 
	       (slot-value condition 'message)))))

;;; Macro to catch ENOENT errors and turn them into nil 
;;; return value.

(defmacro no-existence-error (&body forms)
  (let ((block-sym (gensym "BLOCK-")))
   `(block ,block-sym
     (handler-bind
       ((system-error #'(lambda (con)
			  (declare (ignore con))
			  (if (= unix-funcs:errno unix-funcs:enoent)
			    (return-from ,block-sym nil)))))
	 , at forms))))

;;; Directory access

(define-condition open-dir-error (system-error) ((dir :initarg :dir)))

(defmethod initialize-instance :after ((c open-dir-error) &rest args)
  (declare (ignore args))
  (with-slots (dir message) c
    (setf message (format nil "Unable to open ~A: ~A." 
                          dir (unix-funcs:strerror unix-funcs:errno)))))

(define-condition open-error (system-error) ((path :initarg :path)))

(defmethod initialize-instance :after ((c open-error) &rest args)
  (declare (ignore args))
  (with-slots (path message) c
    (setf message (format nil "Unable to open ~A: ~A." 
                          path (unix-funcs:strerror unix-funcs:errno)))))
   
   
(defun opendir (dir) 
  (cond
    ((null-to-nil (unix-funcs:opendir dir)))
    (t (error (make-condition 'open-dir-error :dir dir)))))

(declaim (inline closedir))
(defun closedir (dir-stream) 
  (when-not-null dir-stream (unix-funcs:closedir dir-stream)))


(defun readdir (dir-stream) 
  (let ((dir-entry (unix-funcs:readdir dir-stream)))
    (if dir-entry
      (with-slots ((name unix-funcs:name) (ino unix-funcs:ino)) dir-entry
        (values name ino))
      nil)))

(defmacro with-open-dir ((var dir) &body forms)
 `(let ((,var (opendir ,dir)))
    (unwind-protect
      (progn , at forms)
      (closedir ,var))))

(define-condition chdir-error (system-error) ((dir :initarg :dir)))

(defmethod initialize-instance :after ((c chdir-error) &rest args)
  (declare (ignore args))
  (with-slots (dir message) c
    (setf message (format nil "Unable to change to directory ~A: ~A." 
                          dir (unix-funcs:strerror unix-funcs:errno)))))

(defun chdir (dir)
  (if (= -1 (unix-funcs:chdir dir))
    (error (make-condition 'chdir-error :dir dir)))
    (values))

(defun fchdir (descr)
  (if (= -1 (unix-funcs:fchdir descr))
    (error (make-condition 'chdir-error 
                           :dir (format nil "[file descriptor ~a]" descr))))
    (values))

(define-condition getcwd-error (system-error) ())

(defmethod initialize-instance :after ((c getcwd-error) &rest args)
  (declare (ignore args))
  (with-slots (message) c
    (setf message (format nil "Unable to determine current directory: ~A." 
                          (unix-funcs:strerror unix-funcs:errno)))))

(declaim (inline getcwd))
(defun getcwd ()
  (or (unix-funcs:getcwd)
      (error (make-condition 'getcwd-error))))

(defmacro current-dir-restore (&body forms)
  (let ((saved-dir (gensym "SAVED-DIR-")))
    `(let ((,saved-dir (unix-funcs:open "." unix-funcs:o-rdonly 0)))
       (when (= ,saved-dir -1)
	 (error (make-condition 'open-error :path ".")))
       (unwind-protect 
	 (macrolet ((in-original-dir (&body inner-forms)
		      (let ((in-saved-dir (gensym "INNER-SAVED-DIR-")))
		        `(let ((,in-saved-dir 
				 (unix-funcs:open "." 
						  unix-funcs:o-rdonly 
						  0)))
			   (when (= ,in-saved-dir -1)
			     (error (make-condition 'open-error :path ".")))
			   (unwind-protect
			     (progn (fchdir ,',saved-dir)
				    (progn , at inner-forms))
			     (fchdir ,in-saved-dir)
			     (unix-funcs:close ,in-saved-dir))))))
	   , at forms)
	 (fchdir ,saved-dir)
	 (unix-funcs:close ,saved-dir)))))
  
;;; File information

(define-condition file-info-error (system-error) ((file :initarg :file)))

(defmethod initialize-instance :after ((c file-info-error) &rest args)
  (declare (ignore args))
  (with-slots (file message) c
    (setf message (format nil "Unable to get status of ~A: ~A." 
                          file (unix-funcs:strerror unix-funcs:errno)))))

(defclass file-info ()
  ((file-name :initarg :file-name :accessor file-name)
   (mode-flags :initarg :mode-flags :accessor mode-flags)
   (mod-time :initarg :mod-time :accessor mod-time)
   (inode :initarg :inode :accessor inode)
   (num-links :initarg :num-links :accessor num-links)))

(defgeneric same-file-p (file1 file2))
(defgeneric older-p (file1 file2))
(defgeneric regular-p (file))
(defgeneric directory-p (file))
(defgeneric symlink-p (file))
(defgeneric is-root-p (file))
(defgeneric get-parent (file))
(defgeneric executable-p (file))
(defgeneric make-executable (file))
(defgeneric make-non-executable (file))

(defmethod same-file-p ((f1 file-info) (f2 file-info))
  (= (inode f1) (inode f2)))

(defmethod same-file-p ((f1 string) (f2 string))
  (= (stat f1) (stat f2)))

(defmethod older-p ((f1 file-info) (f2 file-info))
  (< (mod-time f1) (mod-time f2)))

(defmethod older-p ((f1 string) (f2 string))
  (older-p (stat f1) (stat f2)))

(defmethod regular-p ((file file-info))
  (unix-funcs:s-isreg (mode-flags file)))

(defmethod regular-p ((filename string))
  (regular-p (stat filename)))

(defmethod regular-p ((x null))
  nil)

(defmethod directory-p ((file file-info))
  (unix-funcs:s-isdir (mode-flags file)))

(defmethod directory-p ((filename string))
  (directory-p (stat filename)))

(defmethod directory-p ((x null))
  nil)

(defmethod symlink-p ((file file-info))
  (unix-funcs:s-islnk (mode-flags file)))

(defmethod symlink-p ((filename string))
  (symlink-p (stat filename)))

(defmethod symlink-p ((x null))
  nil)

(defmethod is-root-p ((file file-info))
  (and (directory-p file)
       (same-file-p file (stat (format nil "~a/.." (file-name file))))))

(defmethod is-root-p ((filename string))
  (is-root-p (stat filename)))

(defmethod get-parent ((file file-info))
  (stat (format nil "~a/.." (file-name file))))

(defmethod get-parent ((filename string))
  (stat (format nil "~a/.." filename)))

(defmethod executable-p ((file file-info))
  (with-slots ((mode mode-flags)) file
    (and (not (zerop (logand mode unix-funcs:s-ixusr)))
	 (not (zerop (logand mode unix-funcs:s-ixgrp))))))

(defmethod executable-p ((filename string))
  (executable-p (stat filename)))

(defmethod make-executable ((file file-info))
  (with-slots ((mode mode-flags) file-name) file
    (let ((saved-mode mode))
      (unless (zerop (logand mode unix-funcs:s-irusr))
	(setf mode (logior mode unix-funcs:s-ixusr)))
      (unless (zerop (logand mode unix-funcs:s-irgrp))
	(setf mode (logior mode unix-funcs:s-ixgrp)))
      (unless (zerop (logand mode unix-funcs:s-iroth))
	(setf mode (logior mode unix-funcs:s-ixoth)))
      (unless (= mode saved-mode)
	(unix-funcs:chmod file-name mode)))))

(defmethod make-executable ((filename string))
  (make-executable (stat filename)))

(defmethod make-non-executable ((file file-info))
  (with-slots ((mode mode-flags) file-name) file
    (let ((saved-mode mode))
      (setf mode (logand mode 
			 (lognot (logior unix-funcs:s-ixusr
					 unix-funcs:s-ixgrp
					 unix-funcs:s-ixoth))))
      (unless (= mode saved-mode)
	(unix-funcs:chmod file-name mode)))))

(defmethod make-non-executable ((filename string))
  (make-non-executable (stat filename)))

(defun stat (name &key through-link)
  (if (typep name 'file-info)
    name
    (multiple-value-bind (result stat-info) 
			 (if through-link 
			    (unix-funcs:stat name)
			    (unix-funcs:lstat name))
      (when (= result -1)
	(error (make-condition 'file-info-error :file name)))
      (with-slots ((mode unix-funcs:mode) 
		   (mtime unix-funcs:mtime)
		   (inode unix-funcs:ino)
		   (nlink unix-funcs:nlink)) stat-info
	(make-instance 'file-info :file-name name
				  :mode-flags mode
				  :mod-time mtime
				  :inode inode
				  :num-links nlink)))))

(defun exists (name &key through-link)
  (no-existence-error (stat name :through-link through-link)))

;;; Symbolic and hard links

(define-condition link-error (system-error) 
  ((from-path :initarg :from-path)
   (to-path :initarg :to-path)
   (kind :initarg :kind)))

(defmethod initialize-instance :after ((c link-error) &rest args)
  (declare (ignore args))
  (with-slots (message kind from-path to-path) c
    (setf message (format nil "Unable to make ~A link called ~A referencing ~A."
                          kind to-path from-path
			  (unix-funcs:strerror unix-funcs:errno)))))

(defun link (from to)
  (if (zerop (unix-funcs:link from to))
    (values)
    (error (make-condition 'link-error :from-path from 
			   :to-path to :kind "hard"))))

(defun symlink (from to)
  (if (zerop (unix-funcs:symlink from to))
    (values)
    (error (make-condition 'link-error :from-path from 
			   :to-path to :kind "symbolic"))))

(define-condition readlink-error (system-error) 
  ((path :initarg :path)))

(defmethod initialize-instance :after ((c readlink-error) &rest args)
  (declare (ignore args))
  (with-slots (message path) c
    (setf message (format nil "Unable to read symbolic link ~A: ~A." 
                          path (unix-funcs:strerror unix-funcs:errno)))))

(defun readlink (path)
  (let ((data (unix-funcs:readlink path)))
    (if data
      data
      (error (make-condition 'readlink-error :path path)))))

;;; Directory removal

(define-condition rm-error (system-error) 
  ((path :initarg :path)))

(defmethod initialize-instance :after ((c rm-error) &rest args)
  (declare (ignore args))
  (with-slots (message path) c
    (setf message (format nil "Unable to remove ~A: ~A." 
                          path (unix-funcs:strerror unix-funcs:errno)))))

(defun rmdir (dir)
  (if (zerop (unix-funcs:rmdir dir))
    (values)
    (error (make-condition 'rm-error :path dir))))

(defun unlink (file)
  (if (zerop (unix-funcs:unlink file))
    (values)
    (error (make-condition 'rm-error :path file))))

;;; Coprocesses

(defun shell-interpreter (command)
  (case (shell command)
    ((0) T)
    (otherwise nil)))

(defun execute-program (arglist)
  (chatter-debug "invoking ~s in directory ~s~%" arglist (getcwd))
  (case (unix-funcs:run-program (first arglist) :arguments (rest arglist))
    ((0) (chatter-debug "successful termination~%") T)
    (otherwise (chatter-debug "unsuccessful or abnormal termination~%") nil)))

(defmacro with-input-from-program ((stream-var arg-list) &body forms)
  (let ((arg-list-sym (gensym "ARG-LIST-")))
    `(let ((,arg-list-sym ,arg-list))
       (chatter-debug "piping from ~s in directory ~s~%" ,arg-list-sym (getcwd))
       (unix-funcs:default-sigchld)
       (let* ((,stream-var (make-pipe-input-stream 
			     (arglist-to-command-string ,arg-list-sym))))
	 (declare (dynamic-extent ,stream-var))
	 (when ,stream-var
	   (unwind-protect (progn , at forms) (close ,stream-var)))))))

(defmacro with-output-to-program ((stream-var arg-list) &body forms)
 `(progn
    (unix-funcs:default-sigchld)
    (let* ((,stream-var (make-pipe-output-stream 
			(arglist-to-command-string ,arg-list))))
      (declare (dynamic-extent ,stream-var))
      (when ,stream-var
	(unwind-protect (progn , at forms) (close ,stream-var))))))

;;; GUID generation

(defvar *have-dev-random* t)
(defvar *mcvs-random-state*)

(defun guid-gen ()
  (cond
    (*have-dev-random*
       (or (ignore-errors 
	     (with-open-file (f "/dev/urandom" 
				:direction :input 
				:element-type '(unsigned-byte 128))
	       (read-byte f)))
	   (progn
	     (setf *have-dev-random* nil)
	     (setf *mcvs-random-state* (make-random-state t))
	     (guid-gen))))
    (t (random #.(expt 2 128) *mcvs-random-state*))))

;;; Environment strings
(defun env-lookup (name &optional substitute-if-not-found)
  (let ((value (getenv name)))
    (if value value substitute-if-not-found)))

--- NEW FILE: F-D3884C19BD6F4028992C7EE4A564DCA3.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(provide "restart")

(defmacro can-restart-here ((format-string &rest format-args) &body forms)
  (let ((restart-block (gensym "RESTART-"))
        (stream (gensym "STREAM-")))
   `(block ,restart-block
      (restart-bind 
	((continue #'(lambda () (return-from ,restart-block))
	  :report-function #'(lambda (,stream) 
			       (format ,stream ,format-string , at format-args))))
	, at forms))))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun parse-restart-case-keywords (body)
    (let ((interactive-spec ())
	  (test-spec ())
	  (report-spec()))
      (do ((key (first body) (first body))
	   (val (second body) (second body)))
	  ((not (member key '(:report :test :interactive))))
	(pop body)
	(pop body)
	(case key
	  ((:interactive) 
	   (setf interactive-spec `(:interactive-function (function ,val))))
	  ((:report) 
	   (setf report-spec
		 (cond 
		   ((stringp val)
		      `(:report-function #'(lambda (stream) 
					   (write-string ,val stream))))
		   ((and (consp val) (stringp (first val)))
		      `(:report-function #'(lambda (stream) 
					   (format stream , at val))))
		   (t `(:report-function (function ,val))))))
	  ((:test)
	   (setf test-spec `(:test-function (function ,val))))))
      (values interactive-spec test-spec report-spec body)))

  (defun super-restart-case-expander (clause top-sym out-sym closure-var)
    (destructuring-bind (name lambda-list &rest body) clause
      (multiple-value-bind (interactive-spec test-spec 
			    report-spec body)
			   (parse-restart-case-keywords body)
	`(,name 
	  (macrolet 
	    ((unwind (&body forms)
	       `(progn 
		  (setf ,',closure-var 
			#'(lambda () , at forms))
		  (go ,',out-sym)))
	     (retry ()
	       `(go ,',top-sym)))
	    #'(lambda ,lambda-list , at body))
	  , at interactive-spec , at report-spec , at test-spec)))))

(defmacro super-restart-case (expr &rest clauses)
"This is a macro that is very similar to the standard RESTART-CASE, but
with a few refinements. 

Firstly, the special syntax :REPORT (STRING ...) is accepted.
This is a shorthand for 

  :REPORT (LAMBDA (STREAM) (FORMAT STREAM STRING ...)))

Secondly, unlike RESTART-CASE, SUPER-RESTART-CASE does not perform a
non-local exit before executing the body of a clause. A clause body is
executed in the dynamic context of the restart invocation. In other
words, SUPER-RESTART-CASE clause bodies behave like closures specified
to RESTART-BIND. When the last form in the clause body is executed,
control returns back to the context which invoked the restart.

Thirdly, two special local macros may be used in the bodies of the
clauses to achieve control over the behavior. 

The macro (RETRY) will re-execute the entire SUPER-RESTART-CASE form
from the beginning. This provides an easy way to implement retry
behavior, without having to code an explicit loop.

The macro (UNWIND [ FORMS ...]) causes FORMS to be evaluated after
performing a non-local exit back to the dynamic context of the
SUPER-RESTART-CASE form. When the last of the forms is evaluated, the
entire form terminates. As can be expected, the result of the entire
will be the value of the last form in (UNWIND ...)."
  (let ((top-sym (gensym "TOP-"))
	(out-sym (gensym "OUT-"))
	(closure-var (gensym "CLOSURE-")))
    `(let ((,closure-var nil))
       (block nil
	 (tagbody
	   ,top-sym
	   (restart-bind
	     ,(mapcar #'(lambda (clause)
			  (super-restart-case-expander clause top-sym out-sym
						       closure-var))
		      clauses)
	     (return (progn ,expr)))
	   ,out-sym
	   (return (funcall ,closure-var)))))))

--- NEW FILE: F-D3DC1953503E35C4D11154495DE074FB.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "dirwalk")
(require "system")
(require "split")
(require "seqfuncs")
(require "mapping")
(require "types")
(require "chatter")
(require "options")
(require "checkout")
(require "remove")
(require "add")
(provide "grab")

(defun read-word-hash (&optional (byte-stream t))
  (let ((word-hash (make-hash-table :test #'equalp))
	token
	(state :junk))
    (labels ((new-token () 
	       (if token
		 (setf (fill-pointer token) 0)
		 (setf token (make-array '(8) 
					 :element-type 'character
					 :adjustable t
					 :fill-pointer 0))))
	     (save-token ()
	       (unless (gethash token word-hash)
		 (let ((copy (make-string (length token))))
		   (replace copy token)
		   (setf (gethash copy word-hash) copy)))))
      (do ((byte (read-byte byte-stream nil)
		 (read-byte byte-stream nil)))
	  ((null byte) (if (eq state :word) (save-token)) word-hash)
	(let ((ch (int-char byte)))
	  (ecase state
	    ((:junk)
	      (when (or (alpha-char-p ch) (digit-char-p ch)
			(char= ch #\_))
		(new-token)
		(vector-push-extend ch token)
		(setf state :word)))
	    ((:word)
		(cond
		  ((or (alpha-char-p ch) (digit-char-p ch)
		       (char= ch #\_) (char= ch #\-))
		     (vector-push-extend ch token))
		  (t (setf state :junk)
		     (save-token))))))))))

(defun word-hash-file (name)
  (with-open-file (s (parse-posix-namestring name)
		     :direction :input
		     :element-type 'unsigned-byte)
    (read-word-hash s)))

(defun correlate-word-hashes (hash-1 hash-2)
  (let ((hc-1 (hash-table-count hash-1))
	(hc-2 (hash-table-count hash-2)))
    (when (> hc-1 hc-2)
      (psetf hash-1 hash-2 hash-2 hash-1
	     hc-1 hc-2 hc-2 hc-1))
    (let ((common-count 0))
      (maphash #'(lambda (key element)
		   (declare (ignore key))
		   (when (gethash element hash-2)
		     (incf common-count)))
	       hash-1)
      (let ((total-count (- (+ hc-1 hc-2) common-count)))
	(if (zerop total-count)
	  0
	  (/ common-count total-count))))))

(defun correlate-paths (path-1 path-2)
  (let* ((split-1 (split-fields path-1 *path-sep*))
	 (split-2 (split-fields path-2 *path-sep*))
	 (longer (max (length split-1) (length split-2)))
	 (lcs-len (length (longest-common-subsequence split-1 split-2
						       :test #'string=))))
    (case (- longer lcs-len)
      ((0 1) 1)
      ((2) 95/100)
      ((3) 90/100)
      ((4) 85/100)
      (otherwise 80/100))))

(defun determine-common-words (common-hash added-or-removed-files)
  (dolist (file added-or-removed-files common-hash)
    (maphash #'(lambda (key value)
		 (declare (ignore value))
		 (let ((existing (gethash key common-hash)))
		   (if existing
		     (setf (gethash key common-hash) 
			   (1+ existing))
		     (setf (gethash key common-hash)
			   1))))
	     (second file))))

(defun eliminate-common-words (common-hash files threshold)
  (dolist (file files)
    (maphash #'(lambda (key value)
		 (declare (ignore value))
		 (let ((count (gethash key common-hash)))
		   (if (and count (>= count threshold))
		     (remhash key (second file)))))
	     (second file))))
		 
(defun determine-moved-files (added-files removed-files)
  (let (pairs moved-files taken-added taken-removed)
    (dolist (added added-files)
      (dolist (removed removed-files)
	(let ((correlation (correlate-word-hashes (second added) 
						  (second removed))))
	  (when (>= correlation 30/100)
	    (push (list added removed 
			(* correlation (correlate-paths (first added)
							(first removed))))
		  pairs)))))
    (setf pairs (sort pairs #'> :key #'third))
    (dolist (pair pairs)
      (unless (or (member (first pair) taken-added :test #'eq)
		  (member (second pair) taken-removed :test #'eq))
	(push (first pair) taken-added)
	(push (second pair) taken-removed)
	(push pair moved-files)))
    (values moved-files 
	    (set-difference added-files taken-added :test #'eq)
	    (set-difference removed-files taken-removed :test #'eq))))

(defun determine-moved-symlinks (added-symlinks removed-symlinks moved-files
				 stable-files)
  (let ((add-hash (make-hash-table :test #'equal))
	(remove-hash (make-hash-table :test #'equal))
	moved-symlinks taken-added taken-removed)
    (macrolet ((process-item (item path target hash)
		 `(unless (path-absolute-p ,target)
		    (multiple-value-bind (base dir) (basename ,path)
		      (declare (ignore base))
		      (if (null dir)
			(setf dir "."))
		      (multiple-value-bind (resolved-path out-of-bounds)
					   (canonicalize-path (path-cat 
								dir 
								,target))
			(unless out-of-bounds
			  (push ,item (gethash resolved-path ,hash))))))))
      (dolist (added added-symlinks)
	(destructuring-bind (path target) added
	  (process-item added path target add-hash)))
      (dolist (removed removed-symlinks)
	(with-slots (path target) removed
	  (process-item removed path target remove-hash)))
      (macrolet ((move-symlinks (source-name target-name)
		   `(let ((added-list (gethash ,target-name add-hash))
			  (removed-list (gethash ,source-name remove-hash))
			  (symlink-move-pairs))
		      (dolist (added added-list)
			(dolist (removed removed-list)
			  (push (list added removed (correlate-paths 
						      (first added)
						      (mapping-entry-path removed)))
				symlink-move-pairs)))
		      (setf symlink-move-pairs (sort symlink-move-pairs #'> :key #'third))
		      (dolist (pair symlink-move-pairs)
			(unless (or (member (first pair) taken-added :test #'eq)
				    (member (second pair) taken-removed :test #'eq))
			  (push (first pair) taken-added)
			  (push (second pair) taken-removed)
			  (push pair moved-symlinks))))))
	(dolist (file-move-pair moved-files)
	  (destructuring-bind ((target-name hash-2) 
			       (source-name hash-1 f-file) confidence)
			      file-move-pair
	  (declare (ignore hash-1 hash-2 f-file confidence))
	  (move-symlinks source-name target-name)))
	(dolist (entry stable-files)
	  (with-slots (path) entry
	    (move-symlinks path path)))))
    (values moved-symlinks
	    (set-difference added-symlinks taken-added :test #'eq)
	    (set-difference removed-symlinks taken-removed :test #'eq))))

(defun mcvs-grab (global-options command-options module subdir)
  (find-bind (:test #'string= :key #'first)
	     ((branch "r") (trunk "A"))
	     command-options
    (when (and branch trunk)
      (error "both -r and -A specified."))
    (when (and (not branch) (not trunk))
      (error "specify branch using -r or main trunk using -A."))
    (mcvs-checkout module subdir global-options 
		   `(("d" ,*this-dir*) ,@(if branch (list branch)))
		   :no-generate t)
    (in-sandbox-root-dir
      (let ((mapping (mapping-read *mcvs-map*))
	    invisible-old-paths old-paths
	    old-file-paths new-file-paths 
	    old-symlink-paths new-symlink-paths
	    added-files removed-files stable-files
	    added-symlinks removed-symlinks stable-symlinks)
	(chatter-info "Scanning directory structure.~%")
	(multiple-value-setq (old-paths invisible-old-paths)
			     (separate-if #'real-path-exists mapping
					  :key #'mapping-entry-path))
	(dolist (entry old-paths)
	  (with-slots (path) entry
	    (setf path (abstract-to-real-path path))))
	(multiple-value-setq (old-file-paths old-symlink-paths)
			     (separate :file old-paths
				       :test #'eq
				       :key #'mapping-entry-kind))

	(for-each-file-info (fi *this-dir*)
	  (let* ((path (canonicalize-path (file-name fi))))
	    (cond
	      ((regular-p fi)
		 (push path new-file-paths))
	      ((symlink-p fi)
	         (push path new-symlink-paths))
	      ((directory-p fi)
		(when (path-equal path *mcvs-dir*)
		  (skip))))))

	(multiple-value-setq (stable-files removed-files added-files) 
			     (intersection-difference old-file-paths 
						      new-file-paths
						      :key1 #'mapping-entry-path
						      :test #'equal))

	(multiple-value-setq (stable-symlinks removed-symlinks added-symlinks) 
			     (intersection-difference old-symlink-paths 
						      new-symlink-paths
						      :key1 #'mapping-entry-path
						      :test #'equal))


	(cond
	  ((or (null added-files) (null removed-files))
	     (setf added-files (mapcar #'(lambda (name) (list name)) added-files))
	     (setf removed-files (mapcar #'(lambda (entry) 
					     (with-slots (id path) entry
					       (list path nil id)))
					 removed-files)))
	  (t (chatter-terse "Analyzing ~a added file~:p.~%" (length added-files))
	     (setf added-files (mapcar #'(lambda (name) 
					(list name (word-hash-file name)))
				    added-files))

	     (chatter-terse "Analyzing ~a removed file~:p.~%" (length removed-files))
	     (setf removed-files (mapcar #'(lambda (entry)
					     (with-slots (id path) entry
					       (list path
						     (word-hash-file id) id)))
					 removed-files))
	     (let ((common-word-hash (make-hash-table :test #'equalp)))
	       (determine-common-words common-word-hash added-files)
	       (determine-common-words common-word-hash removed-files)
	       (let ((threshold (max 5 (* 1/5 (+ (length added-files)
						 (length removed-files))))))
		 (eliminate-common-words common-word-hash added-files threshold)
		 (eliminate-common-words common-word-hash removed-files threshold)))
	     (chatter-terse "Determining move candidates.~%")))

	(multiple-value-bind (moved-files added-files removed-files)
			     (if (or (null added-files) (null removed-files))
			       (values nil added-files removed-files)
			       (determine-moved-files added-files 
						      removed-files))
	  (when added-symlinks
	    (chatter-terse "Reading ~a added symbolic link~:p.~%" 
			   (length added-symlinks))
	    (setf added-symlinks (mapcar #'(lambda (path)
					     (list path (readlink path)))
					 added-symlinks)))

	  (multiple-value-bind (moved-symlinks added-symlinks removed-symlinks)
			       (if (or (null added-symlinks)
				       (null removed-symlinks))
				 (values nil added-symlinks removed-symlinks)
				 (determine-moved-symlinks added-symlinks 
							   removed-symlinks
							   moved-files
							   stable-files))

	    (let ((moved-hash (make-hash-table :test #'equal))
		  (all-hash (make-hash-table :test #'equal))
		  (mapping (mapping-read *mcvs-map*)))
	      (dolist (entry mapping)
		(setf (gethash (mapping-entry-id entry) all-hash) entry))
	      (when (or moved-files moved-symlinks)
		(dolist (pair moved-files)
		  (destructuring-bind ((target-name hash-2) 
				       (source-name hash-1 f-file) confidence)
				      pair
		    (declare (ignore hash-1 hash-2))
		    (chatter-terse "moving ~a -> ~a (confidence ~a%)~%" 
			    source-name target-name (round (* confidence 100)))
		    (setf (gethash f-file moved-hash) target-name)))
		(dolist (pair moved-symlinks)
		  (destructuring-bind ((target-name symlink-target)
				       source-entry confidence) pair
		    (declare (ignore symlink-target confidence))
		    (with-slots (id (source-name path)) source-entry
		      (chatter-terse "moving symlink ~a -> ~a~%"
				     source-name target-name)
		      (setf (gethash id moved-hash) target-name))))
		    
		(mapc #'(lambda (entry)
			  (with-slots (id path) entry
			    (let ((replacement (gethash id moved-hash)))
			      (if replacement
				(setf path 
				      (real-to-abstract-path replacement))))))
		      mapping)
		(dolist (entry mapping)
		  (with-slots (kind id path executable) entry
		    (when (and (gethash id moved-hash) (eq kind :file))
		      (unlink id)
		      (link (abstract-to-real-path path) id)
		      (setf executable (executable-p id))))))
	      (dolist (symlink-entry stable-symlinks)
		(with-slots (kind id path target) symlink-entry
		  (let ((map-entry (gethash id all-hash)))
		    (setf (mapping-entry-target map-entry)
			  (readlink path)))))
	      (dolist (pair moved-symlinks)
		(with-slots (kind id path target) (second pair)
		  (let ((map-entry (gethash id all-hash)))
		    (setf (mapping-entry-target map-entry)
			  (readlink (abstract-to-real-path 
				      (mapping-entry-path map-entry)))))))
	      (dolist (file-entry stable-files)
		(with-slots (kind id path) file-entry
		  (let ((map-entry (gethash id all-hash)))
		    (setf (mapping-entry-executable map-entry)
			  (executable-p path)))
		  (when (eq kind :file)
		    (unlink id)
		    (link path id))))
	      (mapping-write mapping *mcvs-map*)
	      (mapping-write mapping *mcvs-map-local*))
	    (when removed-files
	      (mcvs-remove nil (mapcar #'first removed-files) :no-sync t))
	    (when removed-symlinks
	      (mcvs-remove nil (mapcar #'mapping-entry-path removed-symlinks) 
			   :no-sync t))
	    (when added-files
	      (mcvs-add nil global-options 
			nil (mapcar #'first added-files)))
	    
	    (when added-symlinks
	      (mcvs-add nil global-options 
			nil (mapcar #'first added-symlinks)))))))))

(defun mcvs-grab-wrapper (global-options command-options args)
  (flet ((error ()
	   (error "specify module name, and optional subdirectory.")))
    (when (zerop (length args))
      (error))
    (destructuring-bind (module &optional subdir &rest superfluous) args
      (when superfluous
	(error))
      (mcvs-grab global-options command-options module subdir))))

(defconstant *grab-help*
"Syntax:

  mcvs grab { -A | -r branch-name } module-name [ subdirectory-path ]

Options:

  -A                Grab to the main trunk.
  -r branch-name    Grab to the specified branch.

Semantics:

  The grab command is a tool for incorporating external code streams
  into a Meta-CVS module.

  Grab works by comparing the contents of the current directory and its
  subdirectories, to the tip of the trunk or a branch of an existing
  Meta-CVS module. It produces a sandbox which contains a minimized set
  of local edits that are needed to make the branch or trunk in the repository
  look exactly like the current directory.

  These local edits have to be committed just like hand-made edits; the grab
  command itself has no effect on the contents of the repository, and does
  not change the local directory in any way other than by creating the MCVS
  subdirectory.

  If it was run with the wrong arguments, the recovery procedure is simply
  to recursively remove the MCVS subdirectory. Then it's possible to run grab
  again with different arguments, as necessary.

  If the subdirectory-path is specified, then grab will operate on 
  just that subdirectory of the module, making just that subtree look
  like the current directory. The result will be a partial sandbox
  containing local edits to just the visible part of the module.
  (See the help for the checkout command, which also takes a subdirectory path
  parameter to create a partial sandbox).

  Either the -A option or the -r option must be specified. This forces
  users to be explicitly clear about where they want the grab to go;
  the main trunk or a branch.

  Grab performs no merging whatsoever. Its job is to place a new document
  baseline at the tip of a code stream. Third party source tracking is
  performed by grabbing snapshots to a branch, and then merging that branch
  in the usual way. ")

--- NEW FILE: F-DDFDB88C633DE12D1C1F5B3C3312FC20.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(require "mapping")
(require "types")
(require "chatter")
(require "options")
(provide "generic")

(defun mcvs-generic (cvs-command cvs-options command-options command-args 
		     files &key need-sync-before need-sync-after 
		     need-update-after global-if-empty-file-list 
		     no-invoke-cvs)
  (when (and *metaonly-option* files)
    (error "cannot specify both --metaonly option and file arguments."))
  (in-sandbox-root-dir
    (let (files-to-process
	  (filemap (mapping-read *mcvs-map-local*))
	  (do-meta-files (and (or *metaonly-option* *meta-option*)
			      (not *nometa-option*)
			      (or files
				  (not global-if-empty-file-list)
				  *metaonly-option*))))

      (unless *metaonly-option*
	(chatter-debug "Preparing file list.~%")

	(cond
	  ((and (null files)
		global-if-empty-file-list
		*nometa-option*)
	     (setf files-to-process filemap))
	  ((and (null files)
		(not global-if-empty-file-list))
	     (setf files-to-process 
		   (mapping-prefix-matches filemap
					   (sandbox-translate-path "."))))
	  (files
	     (dolist (file files)
	       (can-restart-here ("Continue preparing file list.")
		 (let* ((full-name (sandbox-translate-path file))
			(abs-name (canonicalize-path
				    (real-to-abstract-path full-name)))
			(entries (mapping-prefix-matches filemap abs-name)))
		   (if (not entries)
		     (error "~a is not known to Meta-CVS." full-name)
		     (setf files-to-process (nconc files-to-process 
						   entries)))))))))

      (setf files-to-process (mapping-extract-kind files-to-process :file))

      (when (or files-to-process
		do-meta-files
		global-if-empty-file-list)
	(when need-sync-before
	  (chatter-debug "Synchronizing.~%")
	  (mapping-synchronize :filemap files-to-process
			       :direction :left))
	(unless no-invoke-cvs
	  (current-dir-restore 
	    (chdir *mcvs-dir*) 
	    (chatter-debug "Invoking CVS.~%")
	    (execute-program-xargs `("cvs" ,@(format-opt cvs-options)
				     ,cvs-command ,@(format-opt command-options)
				     , at command-args)
				   `(,@(when do-meta-files
					 (let (metas)
					   (when (exists ".cvsignore")
					     (push ".cvsignore" metas))
					   (when (exists *mcvs-types-name*)
					     (push *mcvs-types-name* metas))
					   (cons *mcvs-map-name* metas)))
				     ,@(mapcar #'(lambda (x) 
						   (basename 
						     (mapping-entry-id x))) 
					       files-to-process)))))
	(when (and do-meta-files need-update-after)
	  (chatter-debug "Updating file structure.~%")
	  (mapping-update))
	(when need-sync-after
	  (chatter-debug "Synchronizing again.~%")
	  (mapping-synchronize :filemap files-to-process
			       :direction :right))))
  (values)))

(defun mcvs-commit-wrapper (cvs-options cvs-command-options mcvs-args)
  (mcvs-generic "commit" cvs-options cvs-command-options nil mcvs-args 
		:need-sync-before t
		:need-sync-after t
		:global-if-empty-file-list t))

(defun mcvs-diff-wrapper (cvs-options cvs-command-options mcvs-args)
  (mcvs-generic "diff" cvs-options cvs-command-options nil mcvs-args
		:need-sync-before t))

(defun mcvs-tag-wrapper (cvs-options cvs-command-options mcvs-args)
  (if (null mcvs-args)
    (error "specify tag optionally followed by files."))
  (mcvs-generic "tag" cvs-options 
		cvs-command-options (list (first mcvs-args)) (rest mcvs-args)
		:global-if-empty-file-list t))

(defun mcvs-log-wrapper (cvs-options cvs-command-options mcvs-args)
  (mcvs-generic "log" cvs-options cvs-command-options nil mcvs-args))

(defun mcvs-status-wrapper (cvs-options cvs-command-options mcvs-args)
  (mcvs-generic "status" cvs-options cvs-command-options nil mcvs-args
		:need-sync-before t))

(defun mcvs-annotate-wrapper (cvs-options cvs-command-options mcvs-args)
  (mcvs-generic "annotate" cvs-options cvs-command-options nil mcvs-args))

(defun mcvs-watchers-wrapper (cvs-options cvs-command-options mcvs-args)
  (mcvs-generic "watchers" cvs-options cvs-command-options nil mcvs-args))

(defun mcvs-edit-wrapper (cvs-options cvs-command-options mcvs-args)
  (mcvs-generic "edit" cvs-options cvs-command-options nil mcvs-args
		:need-sync-before t))

(defun mcvs-unedit-wrapper (cvs-options cvs-command-options mcvs-args)
  (mcvs-generic "unedit" cvs-options cvs-command-options nil mcvs-args 
		:need-sync-before t
		:need-sync-after t))

(defun mcvs-editors-wrapper (cvs-options cvs-command-options mcvs-args)
  (mcvs-generic "editors" cvs-options cvs-command-options nil mcvs-args))

(defun mcvs-sync-to-wrapper (cvs-options cvs-command-options mcvs-args)
  (mcvs-generic "" cvs-options cvs-command-options nil mcvs-args
		:need-sync-before t
		:no-invoke-cvs t))

(defun mcvs-sync-from-wrapper (cvs-options cvs-command-options mcvs-args)
  (mcvs-generic "" cvs-options cvs-command-options nil mcvs-args
		:need-sync-after t
		:no-invoke-cvs t))

--- NEW FILE: F-E3131BB19D8294EBDA5E9BFD1C50BB5D.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "system")
(require "mapping")
(require "options")
(provide "filt")

(defun make-filt-hash (mapping)
  (let ((h (make-hash-table :test #'equal)))
    (dolist (entry mapping h)
      (multiple-value-bind (suffix nosuffix)
			   (suffix (mapping-entry-id entry))
	(declare (ignore suffix))
	(setf (gethash nosuffix h) entry)))))

(defun filt-select-map (filt-options &key remote-module)
  (find-bind (:test #'string= :key #'first :take #'second)
	     ((revision "r") (date "D") (extra-r "r") (extra-d "D")) 
	     filt-options
    (cond
      ((or extra-r extra-d)
	 (error "only one date or revision may be specified."))
      ((or revision date remote-module)
	 (unless remote-module
           (chdir *mcvs-dir*))
	 (with-input-from-program (stream `("cvs" "-Q" 
					    ,(if remote-module "co" "up") "-p"
					    ,@(format-opt filt-options)
					    ,(if remote-module 
					       (format nil "~a/~a"
						       remote-module
						       *mcvs-map-name*)
					       *mcvs-map-name*)))
	   (handler-case
	     (mapping-read stream)
	     (error ()
	       (error "unable to retrieve specified revision of map file.")))))
      (t (mapping-read *mcvs-map-local*)))))

(defun mcvs-filt-loop (filehash)
  (loop
    (let ((line (read-line *standard-input* nil)))	
      (when (null line) 
	(return (values)))
      (loop
	(let ((f-start (search "F-" line :test #'char=))
	      (embedded-in-path (search "/F-" line :test #'char=)))
	  (flet ((is-hex-digit (x) 
		   (or (digit-char-p x)
		       (find x "ABCDEF"))))
	    (cond
	      ((and embedded-in-path (or (and f-start 
					      (< embedded-in-path f-start))
					 (not f-start)))
		(write-string (substring line 0 (+ embedded-in-path 7)))
		(setf line (substring line (+ embedded-in-path 7))))
	      (f-start
		(write-string (substring line 0 f-start))
		(setf line (substring line (+ f-start 2)))
		(when (< (length line) 32)
		  (write-string "F-")
		  (write-line line)
		  (return))
		(cond 
		  ((notevery #'is-hex-digit (substring line 0 32))
		     (write-string "F-")
		     (setf line (substring line 2)))
		  (t (let* ((f-digits (substring line 0 32))
			    (entry (gethash (format nil "F-~a" f-digits)
					    filehash))
			    (suffix (and entry 
					 (suffix (mapping-entry-id entry)))))
		       (setf line (substring line 32))
		       (cond
			 ((null entry)
			    (write-string "F-")
			    (write-string f-digits))
			 ((and suffix 
			       (or (< (length line) (1+ (length suffix)))
				   (not (path-equal (substring line 1 
							       (1+ (length suffix)))
						    suffix))))
			    (write-string "F-")
			    (write-string f-digits))
			 (t (write-string (mapping-entry-path entry))
			    (when suffix
			      (setf line 
				    (substring line 
					       (1+ (length suffix)))))))))))
	      (t (write-line line)
		 (return)))))))))

(defun mcvs-filt (filt-options)
  (in-sandbox-root-dir
    (mcvs-filt-loop (make-filt-hash (filt-select-map filt-options)))))

(defun mcvs-remote-filt (filt-options module)
  (mcvs-filt-loop (make-filt-hash (filt-select-map filt-options 
						   :remote-module module))))


(defun mcvs-filt-wrapper (cvs-options cvs-command-options mcvs-args)
  (declare (ignore cvs-options))
  (when mcvs-args
    (error "no arguments permitted."))
  (mcvs-filt cvs-command-options))

(defun mcvs-remote-filt-wrapper (cvs-options cvs-command-options mcvs-args)
  (declare (ignore cvs-options))
  (unless (= (length mcvs-args) 1)
    (error "module name required."))
  (mcvs-remote-filt cvs-command-options (first mcvs-args)))

--- NEW FILE: F-E8B8309E1270A0D1EDB0FB64AB2298D2.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "dirwalk")
(require "system")
(require "options")
(require "sync")
(require "chatter")
(require "restart")
(require "seqfuncs")
(provide "mapping")

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defconstant *mcvs-dir* "MCVS")
  (defconstant *mcvs-map-name* "MAP")
  (defconstant *mcvs-map-local-name* "MAP-LOCAL")
  (defconstant *mcvs-displaced-name* "DISPLACED"))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defconstant *mcvs-map* #.(path-cat *mcvs-dir* *mcvs-map-name*))
  (defconstant *mcvs-map-local* #.(path-cat *mcvs-dir* *mcvs-map-local-name*))
  (defconstant *mcvs-displaced* #.(path-cat *mcvs-dir* *mcvs-displaced-name*)))

(defvar *displaced-path-prefix* nil)
(defvar *displaced-path-length* nil)

(defun mcvs-locate ()
  (let ((current-dir (split-fields (getcwd) *path-sep*))
	(escape-levels *nesting-escape-option*))
    (dotimes (i (length current-dir) nil)
      (let* ((path-components (butlast current-dir i))
	     (path-string (reduce #'path-cat path-components)))
	(when (and (ignore-errors (stat (path-cat path-string *mcvs-dir*)))
		   (zerop (prog1 escape-levels (decf escape-levels))))
	  (when (> *nesting-escape-option* 0)
	    (chatter-info "using sandbox ~a~%" path-string))
	  (chdir path-string)
	  (return (if (zerop i)
		    "."
		    (reduce #'path-cat (last current-dir i)))))))))

(declaim (inline real-path-exists abstract-to-real-path 
		 real-to-abstract-path))

(defun real-path-exists (path)
  (or (null *displaced-path-prefix*)
      (path-prefix-equal *displaced-path-prefix* path)))

(defun abstract-to-real-path (path)
  (if *displaced-path-length*
    (if (or (= (length path) (1- *displaced-path-length*)) 
	    (= (length path) *displaced-path-length*))
      *this-dir*
      (substring path *displaced-path-length*))
    path))

(defun real-to-abstract-path (path)
  (if *displaced-path-prefix*
    (concatenate 'string *displaced-path-prefix* path)
    path))

(defmacro in-sandbox-root-dir (&body forms)
  (let ((downpath-sym (gensym "DOWNPATH-")))
   `(current-dir-restore 
      (let ((,downpath-sym (mcvs-locate))) 
	(when (not ,downpath-sym)
	  (error "could not locate ~a directory." *mcvs-dir*))
	(let* ((*displaced-path-prefix* (displaced-path-read))
	       (*displaced-path-length* (if *displaced-path-prefix*
					  (length *displaced-path-prefix*))))
	  (flet ((sandbox-translate-path (in-path)
		   (multiple-value-bind (out-path out-of-bounds) 
					(canonicalize-path
					  (if (path-absolute-p in-path)
					    (path-cat *this-dir* in-path)
					    (path-cat ,downpath-sym in-path)))
		      (if out-of-bounds
			(error "path ~a is not within sandbox." out-path)
			out-path))))
	    (symbol-macrolet ((sandbox-down-path ,downpath-sym))
	      , at forms)))))))

(defstruct mapping-entry
  (kind :file)
  (id "")
  (path "")
  (target "")
  (executable nil)
  (raw-plist nil))

(defun equal-mapping-entries (left right)
  (and (eq (mapping-entry-kind left) (mapping-entry-kind right))
       (string= (mapping-entry-id left) (mapping-entry-id right))
       (path-equal (mapping-entry-path left) (mapping-entry-path right))
       (equal (mapping-entry-target left) (mapping-entry-target right))))

(defun equal-filemaps (left right)
  (let ((same t))
    (mapc #'(lambda (le re)
	      (setf same (and same (equal-mapping-entries le re))))
	    left right)
    same))

(defun mapping-entry-parse-plist (entry)
  (with-slots (executable raw-plist) entry
    (destructuring-bind (&key exec &allow-other-keys) 
			raw-plist
      (setf executable exec)))
  (values))

(defun mapping-generate-id (&key no-dir (suffix "") (prefix "F-"))
  (format nil "~a~a~32,'0X~a" 
	  (if no-dir "" (concatenate 'string *mcvs-dir* *path-sep*))
	  prefix
	  (guid-gen) 
	  (if (or (null suffix) (string= "" suffix))
	    ""
	    (concatenate 'string "." suffix))))

(defun mapping-extract-kind (filemap kind)
  (remove-if-not #'(lambda (entry-kind) 
		     (eq entry-kind kind))
		 filemap
		 :key #'mapping-entry-kind))

(declaim (inline mapping-extract-paths))
(defun mapping-extract-paths (filemap)
  (mapcar #'mapping-entry-path filemap))

(defun mapping-lookup (filemap path)
  (find path filemap :test #'path-equal :key #'mapping-entry-path))

(defun mapping-prefix-lookup (filemap prefix)
  (if (path-equal *this-dir* prefix)
    (first filemap)
    (find prefix filemap :test #'path-prefix-equal :key #'mapping-entry-path)))

(defun mapping-prefix-matches (filemap path)
  (if (path-equal *this-dir* path)
    filemap
    (remove-if-not #'(lambda (entry) 
		       (path-prefix-equal path (mapping-entry-path entry))) 
		   filemap)))

(defun mapping-same-id-p (entry-one entry-two)
  (string= (mapping-entry-id entry-one) (mapping-entry-id entry-two)))

(defun mapping-same-path-p (entry-one entry-two)
  (path-equal (mapping-entry-path entry-one) (mapping-entry-path entry-two)))

(defun mapping-rename-files (filemap file-list old-prefix new-prefix)
"Returns a new filemap, in which the pathames in the list file-list are edited
by replacing the old-prefix with the new-prefix. If any path thus created
matches an existing map entry, that map entry is removed. The sorting order
of the map is not preserved."
  (flet ((combine (prefix path)
	   (if (string= path "")
	     prefix
	     (canonicalize-path (path-cat prefix path)))))
    (let* ((op-len (length old-prefix))
	   (delete-map (mapcan #'(lambda (entry)
				   (with-slots (path) entry
				     (if (and (member path file-list 
						      :test #'path-equal)
					      (path-prefix-equal old-prefix
					                         path))
				       (list entry)))) filemap))
	   (replace-map (mapcan #'(lambda (entry)
				    (with-slots (path) entry
				      (let ((new-entry (copy-mapping-entry
							 entry)))
					(setf (mapping-entry-path new-entry)
					      (combine new-prefix
						       (subseq path op-len)))
					(list new-entry))))
				 delete-map)))
    (append 
      (set-difference 
        (set-difference filemap delete-map :test #'mapping-same-path-p)
	replace-map :test #'mapping-same-path-p)
      replace-map))))

(defun malformed-map ()
  (error "malformed map (merge conflicts?): correct and run mcvs update."))

(defun mapping-dupe-check (filemap)
"Signals an error condition if the filemap contains duplicate paths or
duplicate objects. Otherwise returns the filemap, sorted by path."
  (let ((dupes)
	(id-hash (make-hash-table :test #'equal))
	(path-hash (make-hash-table :test #'equal)))
    (dolist (entry filemap)
      (if (gethash (mapping-entry-id entry) id-hash)
	(push entry dupes)
	(setf (gethash (mapping-entry-id entry) id-hash) entry))
      (if (gethash (mapping-entry-path entry) path-hash)
	(push entry dupes)
	(setf (gethash (mapping-entry-path entry) path-hash) entry)))
    (when dupes
      (dolist (dupe dupes)
	(chatter-terse "duplicate ~a -> ~a~%" 
		       (mapping-entry-id dupe) (mapping-entry-path dupe)))
      (error "duplicates in map: correct and run mcvs update.")))
  filemap)

(defun mapping-convert-old-style-in (raw-filemap)
"Converts old-style Meta-CVS file mapping to a list of mapping-entry
structures."
  (mapcar #'(lambda (item)
	      (when (or (not (consp item))
			(not (and (stringp (first item))
				  (stringp (second item)))))
		(malformed-map))
	      (make-mapping-entry :kind :file 
				  :id (first item)
				  :path (second item)))
	  raw-filemap))

(defun mapping-convert-in (raw-filemap)
"Converts a Meta-CVS filemap as read from a file into its internal
representation---a list of mapping-entry structures."
  (mapcar #'(lambda (item)
	      (when (or (not (consp item))
			(not (and (keywordp (first item))
				  (stringp (second item)))))
		(malformed-map))
	      (case (first item)
		((:file)
		   (let ((entry (make-mapping-entry :kind :file
						    :id (second item)
						    :path (third item)
						    :raw-plist (fourth item))))
		     (when (fourth item)
		       (mapping-entry-parse-plist entry))
		     entry))
		((:symlink)
		   (when (not (third item))
		     (error "bad map: symlink ~a has no target."
			    (second item)))
		   (make-mapping-entry :kind :symlink
				       :id (second item)
				       :path (third item)
				       :target (fourth item)
				       :raw-plist (fifth item)))
		(otherwise (error "bad type keyword ~s in map." 
				  (first item)))))
	  raw-filemap))

(defun mapping-convert-out (filemap)
"Converts the internal representation of a Meta-CVS mapping to
the external form that is written out to files."
  (mapcar #'(lambda (entry)
	      (with-slots (kind id path target executable raw-plist) entry
		(if executable
		  (setf (getf raw-plist :exec) t)
		  (remf raw-plist :exec))
		(case kind
		  ((:file) (list* kind id path 
				  (if raw-plist (list raw-plist))))
		  ((:symlink) (list* kind id path target
				     (if raw-plist (list raw-plist))))
		  (otherwise (error "unknown mapping entry type ~s." kind)))))
	  filemap))

(defun mapping-read-raw-map (stream)
  (let ((*read-eval* nil))
    (let ((map (read stream nil :error)))
      (if (or (eq map :error) 
		(and (not (consp map)) (not (null map))))
	(malformed-map)
	map))))

(defun mapping-read (source &key sanity-check)
"Reads a Meta-CVS from a file, optionally performing a check
for duplicate entries"
  (let (filemap)
    ;;
    ;; Read the raw data, ensure that the file contains
    ;; a Lisp object and that it's a list, or at least a cons.
    ;;
    (if (streamp source)
      (setf filemap (mapping-read-raw-map source))
      (restart-case
	(with-open-file (stream source :direction :input)
	  (setf filemap (mapping-read-raw-map stream)))
	(continue ()
	  :report "Pretend that an empty map was correctly read."
	  (setf filemap nil))))
    ;;
    ;; Distinguish between the old-style Meta-CVS map and
    ;; the new one. The old one is a list of lists of strings.
    ;; The new one is a list of lists having a keyword in
    ;; the first position.
    ;;
    (setf filemap (if (or (null filemap) (keywordp (first (first filemap))))
		    (mapping-convert-in filemap)
		    (mapping-convert-old-style-in filemap)))

    (if sanity-check  
      (mapping-dupe-check filemap)
      filemap)))

(defun mapping-write (filemap filename &key sort-map)
  (when *dry-run-option*
    (chatter-debug "not writing to ~a because of -n global option.~%" filename)
    (return-from mapping-write))
  (when sort-map
    (setf filemap (sort (copy-list filemap) 
			#'string< :key #'mapping-entry-id)))
  (let ((raw-filemap (mapping-convert-out filemap)))
    (handler-case 
      (with-open-file (file filename :direction :output)
	(let ((*print-right-margin* 1))
	  (prin1 raw-filemap file)
	  (terpri file)))
      (error (cond) (error "unable to write mapping file: ~a" cond)))))

(defun mapping-synchronize (&key filemap (direction :either))
"Synchronizes the contents of files in the sandbox, and their corresponding
CVS files in the Meta-CVS directory. This must be done before any CVS operation
such as commit or update, so that the Meta-CVS files have the correct contents
reflecting local changes. It must also be done after any CVS update operation, 
to ensure that the newly incorporated changes are propagated to the sandbox"
  (let ((filemap (or filemap (mapping-read *mcvs-map-local*))))
    (dolist (entry filemap)
      (can-restart-here ("Continue synchronizing files.")
	(with-slots (kind id path target executable) entry
	  (when (real-path-exists path)
	    (case kind
	      ((:file)
		 (let ((left id) (right (abstract-to-real-path path)))
		   (case (synchronize-files left right executable
					    :direction direction)
		     ((:left)
		       (chatter-info "sync ~a -> ~a~%" left right))
		     ((:right) 
		       (chatter-info "sync ~a <- ~a~%" left right))
		     ((:same :no-sync))
		     ((:dir)
		       (error "cannot sync, either ~a or ~a is a directory."
			      left right))
		     ((nil) 
		       (error "cannot sync, neither ~a nor ~a exists." 
			      left right)))))
	      ((:symlink)
		 (let* ((symlink (abstract-to-real-path path))
			(linkdata (no-existence-error (readlink symlink))))
		   (when (or (not linkdata)
			     (not (string= linkdata target)))
		     (chatter-info "linking: ~a -> ~a~%" 
				   symlink target)
		     (honor-dry-run (target symlink)
		       (no-existence-error (unlink symlink))
		       (ensure-directories-exist symlink)
		       (symlink target symlink))))))))))))

(defun mapping-difference (old-mapping new-mapping)
"Compute the difference between two mappings. Returns three values:
- a mapping containing only elements added by new-mapping;
- a mapping containing only elements removed by new-mapping; and
- a list of moved items, which contains pairs of elements from both, whose
  object name matches, but path differs."
  (multiple-value-bind (moved-pairs added-items removed-items)
		       (intersection-difference 
			 new-mapping old-mapping
			 :key #'mapping-entry-id :test #'equal
			 :combine #'(lambda (new old)
				      (unless (string= (mapping-entry-path new) 
						       (mapping-entry-path old))
					(list old new)))
			 :squash-nil t)
    (values added-items removed-items moved-pairs)))

(defun mapping-update (&key no-delete-removed)
#.(format nil
"Reads the Meta-CVS mapping files ~a and ~a, the local 
mapping and repository mapping, respectively. It computes the difference
between them and then reorganizes the file structure of the sandbox as
necessary to make the mapping up to date. Then the local mapping file is
overwritten so it is identical to the repository one.  This is necessary to
bring the local structure up to date after incorporating mapping changes
whether they came from the CVS repository, or from local operations."
*mcvs-map-local* *mcvs-map*)
  (let ((old-filemap (mapping-read *mcvs-map-local*))
	(new-filemap (mapping-read *mcvs-map* :sanity-check t))
	(rollback-needed t)
	rollback-remove-items rollback-restore-items)
    (unwind-protect
      (multiple-value-bind (added-items removed-items moved-pairs)
			   (mapping-difference old-filemap new-filemap)
	;; First remove what has to be removed. This way when we
	;; do sanity checks, we won't complain about clobbering things
	;; that are slated to disappear.
	(dolist (item removed-items)
	  (when (real-path-exists (mapping-entry-path item))
	    (let ((real (abstract-to-real-path (mapping-entry-path item))))
	      (chatter-terse "removing ~a~%" real)
	      (unless no-delete-removed
		(restart-case 
		  (honor-dry-run (real)
		    (ensure-directories-gone real))
		  (continue () :report "Ignore file removal error."))
		(push item rollback-restore-items)))))

	(dolist (pair moved-pairs)
	  (let ((old-item (first pair)))
	    (with-slots (path) old-item
	      (when (real-path-exists path)
		(honor-dry-run (path)
		  (ensure-directories-gone (abstract-to-real-path path)))
		(push old-item rollback-restore-items)))))
	
	;; Now check sanity of adds and moves, to verify they don't
	;; clobber any local files.
	(let (clobber-add-items clobber-move-pairs)
	  (dolist (item added-items)
	    (with-slots (kind id path target) item
	      (when (real-path-exists path)
		(let* ((real-path (abstract-to-real-path path))
		       (file-info (exists real-path)))
		  (when (and file-info
			     (case kind
			       ((:file) 
				  (not (same-file-p file-info (stat id))))
			       ((:symlink) 
				  (not (string= (readlink real-path)
						target)))
			       (otherwise t))
			     (not (mapping-lookup old-filemap path)))
		    (push item clobber-add-items))))))
	  
	  (dolist (item moved-pairs)
	    (destructuring-bind (old-item new-item) item
	      (declare (ignore old-item))
	      (with-slots (path) new-item
		(when (real-path-exists path)
		  (let ((file-info (exists (abstract-to-real-path path))))
		    (when (and file-info
			       (not (mapping-lookup old-filemap path)))
		      (push item clobber-move-pairs)))))))

	  (when (or clobber-add-items clobber-move-pairs)
	    (super-restart-case
	      (error "some moves or adds want to overwrite local files or directories.")
	      (info ()
		:report "Print list of adds or moves which want to overwrite." 
		(dolist (item clobber-add-items)
		  (format t "add: ~a~%" 
			  (abstract-to-real-path (mapping-entry-path item))))
		(dolist (pair clobber-move-pairs)
		  (format t "move ~a -> ~a~%" 
			  (abstract-to-real-path (mapping-entry-path
						   (first pair)))
			  (abstract-to-real-path (mapping-entry-path
						   (second pair))))))
	      (continue ()
		:report "Go ahead and overwrite the target files." 
		(unwind)))))

	;; Sanity check passed, complete moves and adds.
	(dolist (item moved-pairs)
	  (destructuring-bind (old-item new-item) item
	    (with-slots ((old-path path) (old-id id)) old-item
	      (with-slots ((new-path path) (new-id id) kind target executable) 
			  new-item
		(let ((real-old-exists (real-path-exists old-path))
		      (real-new-exists (real-path-exists new-path)))
		  (let ((real-old (and real-old-exists
				       (abstract-to-real-path old-path)))
			(real-new (and real-new-exists
				       (abstract-to-real-path new-path))))
		    (cond
		      ((and real-old-exists real-new-exists)
			 (chatter-terse "moving ~a -> ~a~%" real-old real-new))
		      (real-new-exists
			 (chatter-terse "moving (out-of-sandbox) -> ~a~%" real-new))
		      (real-old-exists
			 (chatter-terse "moving ~a -> (out-of-sandbox)~%" real-old)))
		      
		    (when real-new-exists
		      (no-existence-error (honor-dry-run (real-new)
					    (unlink real-new)))
		      (case kind
			((:file) 
			   (synchronize-files new-id real-new executable 
					      :direction :right))
			((:symlink) 
			   (honor-dry-run (target real-new)
			     (ensure-directories-exist real-new)
			     (symlink target real-new))))
		      (push new-item rollback-remove-items))))))))

	(dolist (item added-items)
	  (with-slots (kind id path target executable) item
	    (when (real-path-exists path)
	      (let ((real (abstract-to-real-path path)))
		(can-restart-here ("Continue updating file structure.")
		  (no-existence-error (honor-dry-run (real)
					(unlink real)))
		  (case kind
		    ((:file) 
		       (chatter-terse "adding ~a~%" real)
		       (synchronize-files id real executable
					  :direction :right))
		    ((:symlink)
		       (chatter-terse "linking ~a -> ~a~%" real target)
		       (honor-dry-run (real)
			 (ensure-directories-exist real)
			 (symlink target real))))
		  (push item rollback-remove-items))))))
	(setf rollback-needed nil))
      (when rollback-needed
	(chatter-debug "Undoing directory structure changes.~%")
	(dolist (item rollback-remove-items)
	  (let ((real (abstract-to-real-path (mapping-entry-path item))))
	    (chatter-terse "removing ~a~%" real)
	    (honor-dry-run (real)
	      (ensure-directories-gone real))))
	(dolist (item rollback-restore-items)
	  (with-slots (kind path id target executable) item
	    (let ((real (abstract-to-real-path path)))
	      (chatter-terse "restoring ~a~%" real)
	      (case kind
		((:file) 
		   (synchronize-files id real executable :direction :right))
		((:symlink) 
		   (honor-dry-run (real)
		     (ensure-directories-exist real)
		     (symlink target real)))))))))
    (mapping-write new-filemap *mcvs-map-local*))
  t)

(defun mapping-removed-files (filemap)
  (let ((to-be-removed ())
	(f-hash (make-hash-table :test #'equal)))
    (dolist (entry filemap)
      (setf (gethash (mapping-entry-id entry) f-hash) entry))
    (for-each-file-info (fi *mcvs-dir*)
      (when (and (directory-p fi)
		 (path-equal (basename (file-name fi)) "CVS"))
	(skip))
      (let ((base (basename (file-name fi))))
	(multiple-value-bind (suffix name) (suffix base)
	  (declare (ignore suffix))
	  (when (and (= (length name) 34)
		     (string= (subseq name 0 2) "F-")
		     (not (gethash (file-name fi) f-hash)))
	    (push (file-name fi) to-be-removed)))))
    to-be-removed))

(defun displaced-path-read ()
  (let ((*read-eval* nil))
    (ignore-errors (with-open-file (file *mcvs-displaced* :direction :input)
		     (read file)))))

(defun displaced-path-write (path)
  (with-open-file (file *mcvs-displaced* :direction :output)
    (prin1 path file)
    (terpri file)))

--- NEW FILE: F-E9DFED59ECE7621E4773E6B51E9D2881.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "split")
(provide "posix")

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defconstant *up-dir* "..")
  (defconstant *this-dir* ".")
  (defconstant *path-sep* "/"))

(defvar *mcvs-editor* nil)

(defconstant *argument-limit* (* 64 1024))

(defun canonicalize-path (path)
"Simplifies a POSIX path by eliminating . components, splicing out as many ..
components as possible, and condensing multiple slashes. A trailing slash is
guaranteed to be preserved, if it follows something that could be a file or
directory.  Two values are returned, the simplified path and a boolean value
which is true if there are any .. components that could not be spliced out."
  (let ((split-path (split-fields path "/"))
        uncanceled-up)

    ;; First, if the path has at least two components,
    ;; replace the first empty one with the symbol :root
    ;; and the last empty one with :dir. These indicate a
    ;; leading and trailing /
    (when (and (> (length split-path) 1))
      (when (string= (first split-path) "")
        (setf (first split-path) :root))
      (when (string= (first (last split-path)) "")
        (setf (first (last split-path)) :dir)))

    ;; Next, squash out all of the . and empty components,
    ;; and replace .. components with :up symbol.
    (setf split-path (mapcan #'(lambda (item)
				 (cond
				   ((string= item "") nil)
				   ((string= item ".") nil)
				   ((string= item "..") (list :up))
				   (t (list item)))) 
			     split-path))
    (let (folded-path)
      ;; Now, we use a pushdown automaton to reduce the .. paths
      ;; The remaining stack is the reversed path.
      (dolist (item split-path)
        (case item
	  ((:up)
	    (case (first folded-path)
	      ((:root)) ;; do nothing
	      ((:up nil) (push item folded-path) (setf uncanceled-up t))
	      (otherwise (pop folded-path))))
	  ((:dir)
	    (case (first folded-path)
	      ((:root :up nil))
	      (otherwise (push (concatenate 'string (pop folded-path) "/")
	                       folded-path))))
          (otherwise
	    (push item folded-path))))
      (setf split-path (nreverse folded-path)))

    ;; If there are at least two components, remove a leading :root
    ;; and add a / to the first component. If there are 0 components
    ;; add a "." component.
    (if (zerop (length split-path))
      (push "." split-path)
      (when (eq (first split-path) :root)
	(pop split-path)
	(push (concatenate 'string "/" (or (pop split-path) "")) split-path)))

    ;; Map remaining symbols back to strings
    (setf split-path (mapcar #'(lambda (item)
				 (case item
				   ((:up) "..")
				   (otherwise item))) split-path))

    ;; Convert back to text
    (values (reduce #'(lambda (x y) (concatenate 'string x "/" y)) split-path)
            uncanceled-up)))

(defun basename (path)
"Splits the path into base name and directory, returned as two values.
If the path is / then . and / are returned. The rightmost slash is
used to determine the split between the path and the base name. If there
is a rightmost slash, then everything up to but not including that slash is
returned as the directory (second) value, and everything to the right is 
returned as the base name (first) value. If there is no rightmost slash,
then the directory is returned as NIL, and the path is the entire base name.
If the path has a trailing slash, then that trailing slash is part of the base
name, and does not count as the rightmost slash."
  (let* ((pos1 (position #\/ path :from-end t))
         (pos2 (position #\/ path :end pos1 :from-end t)))
    (cond
      ((string= path "/") 
        (values "." "/"))
      ((null pos1) 
        (values path nil))
      ((= (1+ pos1) (length path))
        (if (null pos2)
          (values path nil)
	  (values (subseq path (1+ pos2)) (subseq path 0 pos2))))
      (t
        (values (subseq path (1+ pos1)) (subseq path 0 pos1))))))

(defun suffix (path &optional (separator-char #\.))
  (multiple-value-bind (name dir) 
		       (basename path)
    (let ((pos (position separator-char name)))
      (cond
        ((eql pos 0)
	   (values nil name dir))
	(pos
	   (values (subseq name (1+ pos)) (subseq name 0 pos) dir))
	(t (values nil name dir))))))

(declaim (inline path-equal))
(defun path-equal (p1 p2)
  (string= p1 p2))

(defun path-prefix-equal (shorter longer)
  (let ((ls (length shorter)) (ll (length longer)))
    (cond
      ((> ls ll) nil)
      ((not (string= shorter longer :end2 ls)) nil)
      ((= ls ll) t)
      ((and (> ls 0) 
	    (char-equal (char shorter (1- ls)) #\/)
	    (char-equal (char longer (1- ls))) #\/) t)
      ((char-equal (char longer ls) #\/) t)
      (t nil))))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun path-cat (first-component &rest components)
    (reduce #'(lambda (x y) (format nil "~a/~a" x y)) components
	    :initial-value first-component)))

(defun path-absolute-p (path)
  (unless (zerop (length path))
    (char= (char path 0) #\/)))

(defun parse-posix-namestring (path)
  (let ((split-path (split-fields path "/")))
    (let ((dir (butlast split-path))
	  (name (first (last split-path))))
      (apply #'make-pathname 
	     `(,@(when dir 
		   `(:directory ,(if (string= "" (first dir))
				   `(:absolute ,@(rest dir))
				   `(:relative , at dir))))
	       ,@(when name
		  `(:name ,name)))))))

(defun arglist-to-command-string (arglist)
"Convert list of strings, assumed to be an argument vector, into
a single command string that can be submitted to a POSIX command 
interpreter. This requires escaping of all shell meta-characters."
  (let ((command (make-array '(1024)
			     :element-type 'character
			     :adjustable t
			     :fill-pointer 0)))
    (dolist (arg arglist command)
      (dotimes (i (length arg))
	(let ((ch (char arg i)))
	  (when (find ch #(#\' #\" #\* #\[ #\] #\? 
			   #\$ #\{ #\} #\" #\space #\tab
			   #\( #\) #\< #\> #\| #\; #\&))
	    (vector-push-extend #\\ command))
	  (vector-push-extend ch command)))
	(vector-push-extend #\space command))))

(defun execute-program-xargs (fixed-args &optional extra-args fixed-trail-args)
  (let* ((fixed-size (reduce #'(lambda (x y)
				 (+ x (length y) 1))
			     (append fixed-args fixed-trail-args)
			     :initial-value 0))
	 (size fixed-size))
    (if extra-args
      (let ((chopped-arg ())
	    (combined-status t))
	(dolist (arg extra-args)
	  (push arg chopped-arg)
	  (when (> (incf size (1+ (length arg))) *argument-limit*)
	    (setf combined-status 
		  (and combined-status
		       (execute-program (append fixed-args 
						(nreverse chopped-arg)
						fixed-trail-args))))
	    (setf chopped-arg nil)
	    (setf size fixed-size)))
	(when chopped-arg
	  (execute-program (append fixed-args (nreverse chopped-arg)
				   fixed-trail-args)))
	combined-status)
      (execute-program (append fixed-args fixed-trail-args)))))

(defun invoke-editor-on (name)
  (let ((editor (or *mcvs-editor* 
		    (env-lookup "CVSEDITOR")
		    (env-lookup "VISUAL")
		    (env-lookup "EDITOR" "vi"))))
    (execute-program `(,editor ,name))))

--- NEW FILE: F-F3CA06292A3D8237E960CB2844A8D5C0.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "split")
(require "mapping")
(require "options")
(require "update")
(require "system")

(defconstant *branch-char* #\~)

(defun tags-from-cvs-log (stream)
"Parse stream which is assumed to be the output of a cvs log -h command
for a single file. Return two associative lists, one of version tags
and one of branch tags."
  (let (syms (state :initial))
    (loop
      (let ((line (read-line stream nil)))
	(when (null line)
          (return-from tags-from-cvs-log (nreverse syms)))
	(ecase state
	  ((:initial)
	    (if (string= line "symbolic names:")
	      (setf state :syms)))
	  ((:syms)
	    (cond 
	      ((and (not (zerop (length line)))
		    (char= (char line 0) #\tab))
		 (push (split-words line #(#\: #\space #\tab)) syms))
	      (t (setf state :final))))
	  ((:final)))))))

(defun parse-dir-sticky (sticky)
  (if (string= "" sticky)
    nil
    (let ((first-char (char sticky 0))
	  (rest-string (substring sticky 1)))
      (case first-char
	(#\T (list :branch rest-string))
	(#\D (list :date rest-string))
	(#\N (list :version rest-string))
	(otherwise (list :other sticky))))))

(defun parse-entries-sticky (sticky)
  (if (string= "" sticky)
    nil
    (let ((first-char (char sticky 0))
	  (rest-string (substring sticky 1)))
      (case first-char
	(#\T (list :tag rest-string))
	(#\D (list :date rest-string))
	(otherwise (list :other sticky))))))

(defun equal-sticky (left right)
  (cond
    ((eq left right) t)
    ((null left) nil)
    ((null right) nil)
    (t (destructuring-bind (type-left text-left) left
	 (destructuring-bind (type-right text-right) right
	   (and (equal text-left text-right)
		(or (eq type-left type-right)
		    (and (eq type-left :tag)
			 (member type-right '(:version :branch)))
		    (and (eq type-right :tag)
			 (member type-left '(:version :branch))))))))))

(defun read-cvs-entries ()
  (with-open-file (f "CVS/Entries" :direction :input :if-does-not-exist nil)
    (when (not f)
      (error "cannot read CVS/Entries"))
    (let (entries)
      (do ((line (read-line f nil) (read-line f nil)))
	  ((null line) (nreverse entries))
	  (let ((split (split-fields line #(#\/))))
	    (setf (first split)
		  (cond 
		    ((string= "" (first split)) :file)
		    ((string= "D" (first split)) :directory)
		    (t :other)))
	    (when (sixth split)
	      (setf (sixth split) (parse-entries-sticky (sixth split))))
	    (push split entries))))))

(defun same-tag-check (entries &optional directory-sticky-tag)
  (let ((file-entries (remove-if-not #'(lambda (x) (eq x :file))
				     entries
				     :key #'first)))
    (let ((first-tag (or directory-sticky-tag (sixth (first file-entries)))))
      (not (find-if-not #'(lambda (x) (equal-sticky x first-tag))
			file-entries :key #'sixth)))))

(defun what-are-we-sticky-to ()
  (with-open-file (f "CVS/Tag" :direction :input :if-does-not-exist nil)
    (if f
      (let ((contents (read-line f nil)))
	(if contents
	  (parse-dir-sticky contents))))))

(defun what-module-is-this ()
  (with-open-file (f "CVS/Repository" :direction :input)
    (read-line f)))

(defun where-is-the-repository ()
  (with-open-file (f "CVS/Root" :direction :input)
    (read-line f)))

(defun branch-tag-check (tag)
  (when (some #'(lambda (ch) (char= ch *branch-char*)) tag)
    (error "tag must not contain ~a character." *branch-char*))
  (when (string= tag "HEAD")
    (error "HEAD is a reserved symbol." *branch-char*)))

(defun mcvs-branch (global-options branch-name)
  (branch-tag-check branch-name)
  (in-sandbox-root-dir
    (let ((branchpoint-tag (format nil "~a~abranch-point" 
				   branch-name *branch-char*)))
      (chdir *mcvs-dir*)
      (chatter-debug "Invoking CVS.~%")
      (execute-program `("cvs" ,@(format-opt global-options) 
			 "tag" "-b" ,branch-name))
      (execute-program `("cvs" ,@(format-opt global-options) 
			 "tag" ,branchpoint-tag)))))

(defun mcvs-branch-wrapper (global-options command-options command-args)
  (declare (ignore command-options))
  (if (/= (length command-args) 1)
    (error "specify branch symbol")
  (mcvs-branch global-options (first command-args))))

(defun cvs-make-or-advance-tag (global-options tag &optional tag-what)
  (let ((module (what-module-is-this))
	(repo (where-is-the-repository)))
    (if (or (not (execute-program `("cvs" ,@(format-opt global-options)
				    "tag" "-d" ,tag ,*mcvs-map-name*)))
	    (not (execute-program `("cvs" ,@(format-opt global-options) 
				    "-d" ,repo "rtag" "-F"
				    ,@(if tag-what `("-r" ,tag-what))
				    ,tag ,module))))
      (error "CVS tagging operation failed."))))

(defun mcvs-merge (global-options command-options branch-name &key remerge-p)
  (branch-tag-check branch-name)
  (in-sandbox-root-dir
    (chdir *mcvs-dir*)
    (let ((branchpoint-tag (format nil "~a~abranch-point" 
				   branch-name *branch-char*))
	  (current-sticky (what-are-we-sticky-to))
	  this-branch
	  (symbols (with-input-from-program (s `("cvs" 
						 ,@(format-opt global-options)
						 "log" "-h" ,*mcvs-map-name*))
		     (tags-from-cvs-log s))))

      (when (not (or (null current-sticky) 
		     (eq (first current-sticky) :branch)))
	(error "working copy is currently updated to a non-branch tag."))

      (setf this-branch (or (second current-sticky) "HEAD"))

      (when (string= this-branch branch-name)
	(error "cannot merge branch to itself."))

      (let* ((even-merge-tag (format nil "~a~amerged-to-~a-0" branch-name 
				     *branch-char* this-branch))
	     (odd-merge-tag (format nil "~a~amerged-to-~a-1" branch-name 
				    *branch-char* this-branch))
	     (branch-tag-pos (position branch-name symbols
				       :key #'first :test #'string=))
	     (even-tag-pos (position even-merge-tag symbols 
				     :key #'first :test #'string=))
	     (odd-tag-pos (position odd-merge-tag symbols 
				    :key #'first :test #'string=))
	     (bp-tag-pos (position branchpoint-tag symbols
				   :key #'first :test #'string=))
	     from-tag to-tag)

	(when (not branch-tag-pos)
	  (error "unable to retrieve branch symbol ~a." branch-name))
	(when (not bp-tag-pos)
	  (error "this is not a Meta-CVS managed branch."))

	(cond
	  (remerge-p
	     (cond
	       ((and even-tag-pos odd-tag-pos) 
		  (if (< even-tag-pos odd-tag-pos)
		    (setf from-tag odd-merge-tag to-tag even-merge-tag)
		    (setf from-tag even-merge-tag to-tag odd-merge-tag)))
	       (odd-tag-pos
		  (setf from-tag branchpoint-tag to-tag odd-merge-tag))
	       (even-tag-pos
		  (setf from-tag branchpoint-tag to-tag even-merge-tag))
	       (t (error "no prior merge was done"))))
	  (t (cond
	       ((and even-tag-pos odd-tag-pos)
		  (if (< even-tag-pos odd-tag-pos)
		    (setf from-tag even-merge-tag to-tag odd-merge-tag)
		    (setf from-tag odd-merge-tag to-tag even-merge-tag)))
	       (even-tag-pos
		  (setf from-tag even-merge-tag to-tag odd-merge-tag))
	       (odd-tag-pos
		  (setf from-tag odd-merge-tag to-tag even-merge-tag))
	       (t (setf from-tag branchpoint-tag to-tag even-merge-tag)))
	     (cvs-make-or-advance-tag global-options to-tag branch-name)))
	(mcvs-update global-options `(("j" ,from-tag) ("j" ,to-tag)
                                  , at command-options))))))

(defun mcvs-list-branches (global-options)
  (in-sandbox-root-dir
    (chdir *mcvs-dir*)
    (let ((symbols (with-input-from-program (s `("cvs" 
						 ,@(format-opt global-options)
						 "log" "-h" ,*mcvs-map-name*))
		      (tags-from-cvs-log s)))
	  (entries (read-cvs-entries))
	  (branchpoint-suffix (format nil "~abranch-point" *branch-char*))
	  (current-sticky (what-are-we-sticky-to)))

      (format t "currently on: ~a (~a)~%" 
	      (or (second current-sticky) "main trunk")
	      (case (first current-sticky)
		((:branch)
		   (if (find (format nil "~a~abranch-point"
				     (second current-sticky) *branch-char*) 
			     symbols :key #'first :test #'string=)
		     "managed branch"
		     "non-managed branch"))
		((:version)
		   "version tag")
		((:date)
		   "sticky date")
		((nil) "no sticky tag")))

      (when (not (same-tag-check entries current-sticky))
	(format t "warning: one or more files not on ~a~%" 
		(or (second current-sticky) "main trunk")))

      (format t "branch list: ~%")
      (dolist (symbol symbols)
	(let* ((tag (first symbol))
	       (offset (search branchpoint-suffix tag)))
	  (when (and offset
		     (> offset 0)
		     (= offset (- (length tag) (length branchpoint-suffix))))
	    (format t "~a~a~%" #\Tab (substring tag 0 offset))))))))

(defun mcvs-merge-wrapper (global-options command-options command-args)
  (when (/= (length command-args) 1)
    (error "specify source branch symbol."))
  (mcvs-merge global-options command-options (first command-args)))

(defun mcvs-remerge-wrapper (global-options command-options command-args)
  (when (/= (length command-args) 1)
    (error "specify source branch symbol."))
  (mcvs-merge global-options command-options (first command-args) :remerge-p t))

(defun mcvs-list-branches-wrapper (global-options command-options command-args)
  (declare (ignore command-options))
  (when (not (zerop (length command-args)))
    (error "command takes no arguments."))
  (mcvs-list-branches global-options))

(defun mcvs-switch-wrapper (global-options command-options command-args)
  (let ((up-opt (case (length command-args)
		  ((0) `("A"))
		  ((1) `("r" ,(first command-args)))
		  (otherwise 
		    (error "specify at most one branch tag.")))))
    (mcvs-update global-options `(,up-opt , at command-options))))

(defconstant *branch-help*
"Syntax:

  mcvs branch branch-name

Options:

  none

Semantics

  A branch can sprout from any point in the repository history. The branch
  command makes a branch starting at the closest repository revisions of all
  files in the sandbox, and associates that branch with the given branch name,
  which must be unique among branch names and tags.

  A branch is a fork in the revision history of a project. When a project is
  created, it has one branch which is called the main trunk. Every branch has
  a tip, which consists of the latest committed revisions of the files.
  Committing changes advances the tip to include newer revisions, causing
  the superseded revisions to recede into the branch history. That is how
  the repository grows to include new material, without losing past versions.

  Branches are needed for two reasons: to isolate changes, and to create
  changes based on old work.

  Isolating changes from each other is important for managing the risks
  associated with making changes to software (known as ``change management'').
  Branches decouple the work of making the changes from the decisions about
  what version of the software those changes will be integrated into.  For
  example, branching allows developers to put only critical bugfixes into an
  upcoming software release, while continuing to develop new features for a
  future version after that release. This is done by creating a branch for the
  critical bugfixes, and then eventually making the release from that branch,
  while development takes place on the trunk.  The trunk also needs the
  critical bugfixes that are put into the release.  These fixes don't have to
  be done twice. Rather, the branch is merged to the trunk, which is a mostly
  automatic process, triggered by the invocation of the merge command.
  A branch can also be created to isolate risky experimental changes, so
  that their intergration can be delayed until they are stable, without
  the need to suspend the actual work of writing the changes.

  Secondly, a branch is needed when a change must be made based on file
  revisions that are no longer at the tip of their branch. Since commits happen
  only at the tip, when changes must be based on some historic version rather
  than the latest version, a branch is used. This mechanism allows developers
  to fix a bug in some old version of the software, and send that fix to the
  customer who doesn't want to, or cannot upgrade to the latest version.
  If that fix is pertinent to the latest version of the software, that branch
  can be merged to the trunk; even if the fixed version is very old, it's
  possible that the fix will merge with only a fraction of the effort that
  would be required to re-do the fix.

  Branches are only an important tool; making effective use of branching
  requires that the users understand, agree upon and follow an intelligent
  change management process.")

--- NEW FILE: F-FABFD2A24671001E7FA5E630FED91059.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(provide "multi-hash")

(defclass multi-hash ()
  ((dimensions :initarg :dimensions :accessor dimensions)
   (root-hash :initform nil)
   (tests :initform nil :initarg :tests :accessor tests)))

(defmethod initialize-instance :after ((h multi-hash) &rest stuff)
  (declare (ignore stuff))
  (with-slots (dimensions root-hash tests) h
    (setf root-hash (make-hash-table :test (or (first tests) #'eql)))))

(defmacro multi-hash-common-code (setf-p)
  `(with-slots (dimensions root-hash tests) multi-hash
     (do* ((i 0 (1+ i))
	   (next-hash nil (or (gethash (first arg) current-hash)
			      ,(if setf-p
				 `(setf (gethash (first arg) current-hash)
					(make-hash-table :test (or (nth i tests) 
								 #'eql)))
				 `(return (values nil nil)))))
	   (arg args (rest arg))
	   (current-hash root-hash next-hash))
	  ((= i (1- dimensions)) 
	    ,(if setf-p
	       `(setf (gethash (first arg) current-hash) (second arg))
	       `(gethash (first arg) current-hash))))))

(defun get-multi-hash (multi-hash &rest args)
  (multi-hash-common-code nil))

(defun set-multi-hash (multi-hash &rest args)
  (multi-hash-common-code t))

(defsetf get-multi-hash set-multi-hash)

--- NEW FILE: F-FD67F73260C22A0EC7EF43A6F702E80F.lisp ---
;;; This source file is part of the Meta-CVS program, 
;;; which is distributed under the GNU license.
;;; Copyright 2002 Kaz Kylheku

(require "memoize")
(provide "seqfuncs")

(defun separate-if (test sequence &rest keys)
  (let ((wheat (apply #'remove-if-not test sequence keys))
        (chaff (apply #'remove-if test sequence keys)))
    (values wheat chaff)))

(defun separate (item sequence &key (test #'eql) key)
  (let ((wheat (funcall #'remove-if-not #'(lambda (x) (funcall test item x))
				      sequence :key key))
        (chaff (funcall #'remove item sequence :key key :test test)))
    (values wheat chaff)))

(define-memoized-function lcs-list ((list-1 :test #'eq)
				    (list-2 :test #'eq) 
				    &key (test #'eql))
  (cond
    ((null list-1) nil)
    ((null list-2) nil)
    ((funcall test (first list-1) (first list-2))
       (cons (first list-1) (lcs-list (rest list-1) (rest list-2))))
    (t (let ((lcs-1 (lcs-list list-1 (rest list-2)))
	     (lcs-2 (lcs-list (rest list-1) list-2)))
	 (if (> (length lcs-1) (length lcs-2))
	   lcs-1
	   lcs-2)))))

(defun lcs-vector (vec-1 vec-2 &key (test #'eql))
  (let ((list-1 (coerce vec-1 'list))
	(list-2 (coerce vec-2 'list)))
    (coerce (lcs-list list-1 list-2 :test test) 'vector)))

(defun longest-common-subsequence (seq-1 seq-2 &key (test #'eql))
  (etypecase seq-1
    (list (lcs-list seq-1 seq-2 :test test))
    (vector (lcs-vector seq-1 seq-2 :test test))))

(defun intersection-difference (seq1 seq2 
				&key (key #'values) key1 key2 (test #'eql)
				(combine #'values) squash-nil)
"Finds the intersection, and mutual differences between two sets.
Returns three values: a sequence of elements that are members of seq1 and seq2;
a sequence of elements that are in seq1 only; and a sequence of elements
that are in seq2 only.

Arguments and values:

seq1 seq2       The input sequences.
:key            Monadic function that specifies what part of
                the element of either sequence to extract. By default,
                takes the element itself as the value.
:key1           Override :key value for elements of seq1.
:key2           Override :key value for elements of seq2.
:combine        Dyadic function which specifies how matching elements from seq1 and
                seq2 are combined to form the intersection. The parameters
                to the function are an element from seq1 and a matching
                counterpart from seq2. The default function takes 
                the seq1 element.
:squash-nil     If the combine function returns NIL, do not include the
                value in the intersection set. Default is NIL, do not squash."
  (setf key1 (or key1 key))
  (setf key2 (or key2 key))

  (let ((hash1 (make-hash-table :test test))
	(hash2 (make-hash-table :test test))
	(intersection ())
	(difference1 ())
	(difference2 ()))
    (dolist (i1 seq1)
      (setf (gethash (funcall key1 i1) hash1) i1))
    (dolist (i2 seq2)
      (setf (gethash (funcall key2 i2) hash2) i2)
      (multiple-value-bind (i1 found)
			   (gethash (funcall key2 i2) hash1)
	(if found
	  (let ((combined (funcall combine i1 i2)))
	    (unless (and squash-nil (null combined))
	      (push (funcall combine i1 i2) intersection)))
	  (push i2 difference2))))
    (dolist (i1 seq1)
      (multiple-value-bind (i2 found)
			   (gethash (funcall key1 i1) hash2)
	(declare (ignore i2))
	(unless found
	  (push i1 difference1))))
    (values intersection difference1 difference2)))

Index: MAP
===================================================================
RCS file: /cvsroot/gennf/gennf/MAP,v
retrieving revision 1.8
retrieving revision 1.9
diff -C2 -d -r1.8 -r1.9
*** MAP	1 Dec 2005 16:46:42 -0000	1.8
--- MAP	2 Dec 2005 10:48:18 -0000	1.9
***************
*** 1,3 ****
--- 1,18 ----
  ((:FILE
+   "MCVS/F-01BFC84C7B5AA5916B1FC95B481B0DEC.lisp"
+   "src/types.lisp")
+  (:FILE
+   "MCVS/F-1474E393BE5A7EE83A4D941FA7F9346D.lisp"
+   "src/watch.lisp")
+  (:FILE
+   "MCVS/F-14CAFC7D376F98290437724D067E63D4.lisp"
+   "src/remap.lisp")
+  (:FILE
+   "MCVS/F-1923CF213AD21CBF66474E7C068BFECD.lisp"
+   "src/split.lisp")
+  (:FILE
+   "MCVS/F-21E77680CDA9B7DA5133627E47FA0987.lisp"
+   "src/error.lisp")
+  (:FILE
    "MCVS/F-22C92A155BD388578902893F5FF7091C"
    "src/make_image"
***************
*** 5,31 ****
     T))
   (:FILE
    "MCVS/F-30CE3B42F628E6E185661335E4018306.lisp"
    "src/gpgme/gpgme.lisp")
   (:FILE
    "MCVS/F-3E293DB4FDF7D70F72EC266B13D28C65.txt"
    "doc/description.txt")
   (:FILE
    "MCVS/F-4A3E7EA0D66193EB3C63340BB6150E24"
    "src/gpgme/Makefile")
   (:FILE
    "MCVS/F-58D8930AD0215DAF4F30E752A5EF3EA1"
    "doc/Makefile")
   (:FILE
    "MCVS/F-A518EEFCABEE08D248A87C9289283D09"
    "LICENSE")
   (:FILE
    "MCVS/F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex"
    "doc/scratchpad.tex")
   (:FILE
    "MCVS/F-E63AF5C74FCD768D115032F86E86B4E6.txt"
    "doc/proposal.txt")
   (:FILE
    "MCVS/F-F0479D3BD4B6A3EB301F19E55A829B7E"
    "src/unix-bindings-linking-set/clisp_mcvs"
    (:EXEC
!    T)))
--- 20,150 ----
     T))
   (:FILE
+   "MCVS/F-24AFFF4D581EFC1C6EF802B4AAB5D27B.lisp"
+   "src/system.lisp")
+  (:FILE
    "MCVS/F-30CE3B42F628E6E185661335E4018306.lisp"
    "src/gpgme/gpgme.lisp")
   (:FILE
+   "MCVS/F-32A3BA955BE6E0F48ABEDF5C42137D5E.lisp"
+   "src/convert.lisp")
+  (:FILE
+   "MCVS/F-389E31FE3917AE1504A5DED502AE3D51.lisp"
+   "src/print.lisp")
+  (:FILE
+   "MCVS/F-3C5788EDE4B0D9B8845BDDF41278246B.lisp"
+   "src/options.lisp")
+  (:FILE
+   "MCVS/F-3CDB81902ABA8CED95DEEBDA8590315E.lisp"
+   "src/chatter.lisp")
+  (:FILE
    "MCVS/F-3E293DB4FDF7D70F72EC266B13D28C65.txt"
    "doc/description.txt")
   (:FILE
+   "MCVS/F-40CE98E89C297E85E8209004EE49D372.lisp"
+   "src/checkout.lisp")
+  (:FILE
+   "MCVS/F-418A4A44531B20FCEB6851D533A75A04.lisp"
+   "src/create.lisp")
+  (:FILE
    "MCVS/F-4A3E7EA0D66193EB3C63340BB6150E24"
    "src/gpgme/Makefile")
   (:FILE
+   "MCVS/F-4F2D9B26F5FB9FA0F66EBB82BE7E8EF1.lisp"
+   "src/prop.lisp")
+  (:FILE
+   "MCVS/F-4F34E424D04A8DF9D18E24CFE19D425C.lisp"
+   "src/memoize.lisp")
+  (:FILE
+   "MCVS/F-54A44C0786853024F450D715BBB3997E.lisp"
+   "src/move.lisp")
+  (:FILE
    "MCVS/F-58D8930AD0215DAF4F30E752A5EF3EA1"
    "doc/Makefile")
   (:FILE
+   "MCVS/F-5B815906BE2D64E9BC2E48B76242BFF2.lisp"
+   "src/sync.lisp")
+  (:FILE
+   "MCVS/F-6763C87866B0E9BE56C154839D6FAB55.lisp"
+   "src/purge.lisp")
+  (:FILE
+   "MCVS/F-6C2D433380C1B1B204522582A4F30484.lisp"
+   "src/slot-refs.lisp")
+  (:FILE
+   "MCVS/F-74915F0862B511AC9C233FDCB87DBEF8.lisp"
+   "src/update.lisp")
+  (:FILE
+   "MCVS/F-7849808E8711BA9FBEB0917F33B12A79.lisp"
+   "src/find-bind.lisp")
+  (:FILE
+   "MCVS/F-8E73F07FB339A6981C69AF06C278B49A.lisp"
+   "src/rcs-utils.lisp")
+  (:FILE
+   "MCVS/F-97770D7ED2DFF388BC60EAB380950A77.lisp"
+   "src/dirwalk.lisp")
+  (:FILE
+   "MCVS/F-9FD71CEB3A8045B747F54A629ED92A8D.lisp"
+   "src/remove.lisp")
+  (:FILE
+   "MCVS/F-A30F4DBDE92A478CEB73EF64056E4340.lisp"
+   "src/restore.lisp")
+  (:FILE
+   "MCVS/F-A3262E4C63ABCB9396F1C019B9CAE540.lisp"
+   "src/cmucl-unix.lisp")
+  (:FILE
+   "MCVS/F-A371BDB8A9CF854FE00C63C1264B1D99.lisp"
+   "src/mcvs-main.lisp")
+  (:FILE
    "MCVS/F-A518EEFCABEE08D248A87C9289283D09"
    "LICENSE")
   (:FILE
+   "MCVS/F-A580617EC4FE7BAAC13B25642EF48CAC.lisp"
+   "src/add.lisp")
+  (:FILE
    "MCVS/F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex"
    "doc/scratchpad.tex")
   (:FILE
+   "MCVS/F-C25BFAA9CFD16915F31BF90D03646B52.lisp"
+   "src/link.lisp")
+  (:FILE
+   "MCVS/F-C534B6E74FE1BD1E409FAAFBB6DC110B.sh"
+   "src/install.sh"
+   (:EXEC
+    T))
+  (:FILE
+   "MCVS/F-CA4E16937768388DD32FAD6ADA8B6A2F.lisp"
+   "src/clisp-unix.lisp")
+  (:FILE
+   "MCVS/F-D3884C19BD6F4028992C7EE4A564DCA3.lisp"
+   "src/restart.lisp")
+  (:FILE
+   "MCVS/F-D3DC1953503E35C4D11154495DE074FB.lisp"
+   "src/grab.lisp")
+  (:FILE
+   "MCVS/F-DDFDB88C633DE12D1C1F5B3C3312FC20.lisp"
+   "src/generic.lisp")
+  (:FILE
+   "MCVS/F-E3131BB19D8294EBDA5E9BFD1C50BB5D.lisp"
+   "src/filt.lisp")
+  (:FILE
    "MCVS/F-E63AF5C74FCD768D115032F86E86B4E6.txt"
    "doc/proposal.txt")
   (:FILE
+   "MCVS/F-E8B8309E1270A0D1EDB0FB64AB2298D2.lisp"
+   "src/mapping.lisp")
+  (:FILE
+   "MCVS/F-E9DFED59ECE7621E4773E6B51E9D2881.lisp"
+   "src/posix.lisp")
+  (:FILE
    "MCVS/F-F0479D3BD4B6A3EB301F19E55A829B7E"
    "src/unix-bindings-linking-set/clisp_mcvs"
    (:EXEC
!    T))
!  (:FILE
!   "MCVS/F-F3CA06292A3D8237E960CB2844A8D5C0.lisp"
!   "src/branch.lisp")
!  (:FILE
!   "MCVS/F-FABFD2A24671001E7FA5E630FED91059.lisp"
!   "src/multi-hash.lisp")
!  (:FILE
!   "MCVS/F-FD67F73260C22A0EC7EF43A6F702E80F.lisp"
!   "src/seqfuncs.lisp"))

--- F-00C35BDA7066AC107B37940B8A805C05.lisp DELETED ---

--- F-025D9893A3E0354B85A37E769E151F35.lisp DELETED ---

--- F-028A9D98A2C6CC50B4EE0B2628784ABC.ist DELETED ---

--- F-0571E3ADC3C861BB4201C0D50BBD080F.lisp DELETED ---

--- F-07ECAC7A6912ACBD1F58136F8C7851FC DELETED ---

--- F-07F5F323E1470D45AE3797943D9F09C0.lisp DELETED ---

--- F-0B3DE1676D640B6284B2AB52D6EA8EB4 DELETED ---

--- F-0DB6763AB5A2920F71ECAA622A0080EB DELETED ---

--- F-0F588B44AA6134780FC75F766E81718A.lisp DELETED ---

--- F-0FDB5E35B3A7F9BF1BD884EF53696A55.lisp DELETED ---

--- F-1133F35CE972E157EB008BF7968FA4EB.lisp DELETED ---

--- F-1741BA39562AC666349637CAD1C2FE22.lisp DELETED ---

--- F-184B4E916574917A6C9E0EE01159F4FA.lisp DELETED ---

--- F-18B9CB29CA124180C8F2C5BF00637E1A.lisp DELETED ---

--- F-2A21AE075C3E7DF766F800FA4BD14C92.lisp DELETED ---

--- F-2DB6E4F50A2F184866E02786BC116057 DELETED ---

--- F-317EC0D21972EC27E3AD31F6585E43C6.lisp DELETED ---

--- F-319FF2C164F29F9653561D842E7235CE.lisp DELETED ---

--- F-32231FAFC8CBEDAAC480487558AC4161.lisp DELETED ---

--- F-3233593F7DB15EC4F2A2E6E89CEF9357.lisp DELETED ---

--- F-37A2AE760DB6B6B72D9EB9CE1FA7B1DA.lisp DELETED ---

--- F-37F38DA9F697247D7C16D57637448F68.lisp DELETED ---

--- F-3AA88479885D9ADF2B9919237F3A6272 DELETED ---

--- F-3B6DEE3AF3E274361CBAC091A01B06BD.lisp DELETED ---

--- F-3EB579DE389A5EE173021BEC02BA59BE.lisp DELETED ---

--- F-4734C5CBB656981507155EF842738409.lisp DELETED ---

--- F-479BF655B94AC8236F1B1655CDA889B8.lisp DELETED ---

--- F-49A639980544EBC9EE5219DABA1B7ABC.lisp DELETED ---

--- F-4C367C3FCE5E39D0D091F2F7004E720C.lisp DELETED ---

--- F-4DA86A8AB987565A410E8A6254281DB6.lisp DELETED ---

--- F-4F7212DDF5CB055227A020E4503020B8.lisp DELETED ---

--- F-503EB9C1ED94503BE865AE52C2BBEB43.lisp DELETED ---

--- F-57795A1A0A45E15ECB67B6597426E8D0.lisp DELETED ---

--- F-59B8F91B14178E72E2EE11D6218CAC70.lisp DELETED ---

--- F-5C432E7F33D77F8EFDB047B6A42B7B75.sh DELETED ---

--- F-5F74E0CDBCCED50B7F581BBE6F00FAF9.lisp DELETED ---

--- F-5F9B4F1F7061BD1C399594B681CB0FB2.lisp DELETED ---

--- F-5FE639B12E294972A2CBE027D579B0BB.sh DELETED ---

--- F-605D165A2362E2E68637D8C6B8FEDD72 DELETED ---

--- F-60EEA232662DB891B60E86DD118F1635 DELETED ---

--- F-61163B6E9FB184FE5FFDEEF2F1A2B4E3.lisp DELETED ---

--- F-634B9707B2ACF7059577CF74C6098D32.lisp DELETED ---

--- F-63943879FE8CCC8BF69C0A0ED0B07B4C.lisp DELETED ---

--- F-64ACAF6D7F846228100313CD78197481.lisp DELETED ---

--- F-650AE495558EEDC296536D1625FB0293.lisp DELETED ---

--- F-69DE21066EED94595C02FFE4D67ADA71.c DELETED ---

--- F-6A3B8283DEC0D30CC3ABE1585C767F64 DELETED ---

--- F-747F81C82C72BFA612378BB6721B4704.lisp DELETED ---

--- F-7728805CEA8BF8B5B162C89BEEF8C673.sh DELETED ---

--- F-8060FF37280530E28B7AACEDBCE90B32.lisp DELETED ---

--- F-8592E33D84C8F2674CE53AC0BC62941C.lisp DELETED ---

--- F-861F3E07A039F60A03D9A26BCDD4D7AC.lisp DELETED ---

--- F-87735485B9B38C990B088267B2215327.lisp DELETED ---

--- F-88A0F15C04414A0935B59A1AD29E382F.lisp DELETED ---

--- F-89F6E5CF7D4C0F48870071E4465CF225.lisp DELETED ---

--- F-8E719B54590CDE2E0C00E5DC2255C0B1.sh DELETED ---

--- F-8F812984949A67FDDD1B3E267B82C1FD DELETED ---

--- F-9320104EE7232348D04D1AD757CF7C24.lisp DELETED ---

--- F-933C47A4AD28A911B511E1F62A68D951.lisp DELETED ---

--- F-954F4F38EDD0B8E80BA52F35F7983F27.lisp DELETED ---

--- F-95E09617AEC5EDFE0EC797F917A64FA0.sh DELETED ---

--- F-9625B65CA4569963240DC474FF5A660B.lisp DELETED ---

--- F-9B3046CE0B253D47337A868F2B329FCE.lisp DELETED ---

--- F-9E8034BD24DF209B5A68EFFA3D656A65.lisp DELETED ---

--- F-A2F0D53F3972E01F0E3240CA7F75E6EB.sh DELETED ---

--- F-A5CD2C18CE0FF0AD73BDB0CA99123878.lisp DELETED ---

--- F-A7EA5C6198D600662EBA114FC41FD488.lisp DELETED ---

--- F-AAEF1F6B6937396D2AF4861A53BFF842.lisp DELETED ---

--- F-AC6FFD08863A247C56335FAB03769D2F.lisp DELETED ---

--- F-B4489B10AC22397DFEA2BD0D85930DF8 DELETED ---

--- F-B455E2F5876C880968318A171FCB4853.latex DELETED ---

--- F-B4C5C058E1DFD5A77275CAF1AEC33DD9.lisp DELETED ---

--- F-B517C41E182902590354C7BA9B0BAE09.c DELETED ---

--- F-B6EB3F44E66501DC1F8BCC07D165DB4C.lisp DELETED ---

--- F-B74A127F1841B4D1B03A8FCD244E0715.lisp DELETED ---

--- F-B83FC9C912884411E2E2015D30380BE9.lisp DELETED ---

--- F-B930BAD3E1D185765A3DD97D4351F82D.lisp DELETED ---

--- F-BAAFB6598E15E0E71277BF5291DC42CB DELETED ---

--- F-BB213ACA68F2DA904308117C35A27C9D.lisp DELETED ---

--- F-C0BF6DD463C4D82B6CCAEAC3A734BB56.lisp DELETED ---

--- F-C197705093E384F68748B1AAABF1DC4A.lisp DELETED ---

--- F-C237DDD5AF623EDA110AF9C4F8EE6734 DELETED ---

--- F-C30C0CEC7A1C945CB7C1A8D0046C009C.lisp DELETED ---

--- F-C65C45C760C921E4D9F84B5260AE3A2E.lisp DELETED ---

--- F-C72A9344C257975CE9A523BED8DE66B9 DELETED ---

--- F-CAF58587D931E55591708041E3D53562.lisp DELETED ---

--- F-CB12D05390173038BB08D8CA304EA307 DELETED ---

--- F-CC6A7181D709E537A384ECB71F6AC2C3.lisp DELETED ---

--- F-D3DF051CCD076B2E0A191D5C7D7DD1D7.lisp DELETED ---

--- F-DAF41B17CCE0195ED5DAB89478B53299.lisp DELETED ---

--- F-DB6CEB89C4D0AC23CFE2F3799E422D5A.lisp DELETED ---

--- F-DC28E9798FD01F6EE465607C65887C9E DELETED ---

--- F-DC5DF0C9C3EF04610466816C4F0B7089.lisp DELETED ---

--- F-DFB1DA78A786291438ECCCFE777860C6 DELETED ---

--- F-E69402D296A3F425C648A56444B01BEB.lisp DELETED ---

--- F-E906A48A7BAB8F2E78B1A9B530AE2C5D DELETED ---

--- F-ECED9C4D66244A93B0736FEFEEAF300E.lisp DELETED ---

--- F-ED6E4C207420921B58786D332C5A2DAA.lisp DELETED ---

--- F-F05B317290FB8206E5A3903521B3AB73.lisp DELETED ---

--- F-F077F0B8EF5CF2118C423B46F6F3D805.lisp DELETED ---

--- F-F27283D0E7915421E2244E8E01E7EB37.lisp DELETED ---

--- F-F65C0C32D6B154F0720474C58DD9F204 DELETED ---

--- F-FB1D47375CBBAE2E22A64602B8DB35C9.lisp DELETED ---

--- F-FD26EA3F7C3CC0DEB8C0E08A324BD744.lisp DELETED ---

--- F-FE773F5202DF77B632899F786009555F.lisp DELETED ---

--- F-FF2986C5A61164C024BADA47D42C0FBC.lisp DELETED ---



From nobody at sheep.berlios.de  Fri Dec  2 12:11:43 2005
From: nobody at sheep.berlios.de (florenz)
Date: Fri, 2 Dec 2005 12:11:43 +0100
Subject: [gennf-devel] gennf F-30CE3B42F628E6E185661335E4018306.lisp,1.1,1.2
Message-ID: <200512021111.jB2BBhN09229@bat.berlios.de>

Update of /cvsroot/gennf/gennf
In directory sheep:/tmp/cvs-serv23909

Modified Files:
	F-30CE3B42F628E6E185661335E4018306.lisp 
Log Message:
Added a GPL-header to gpgme.lisp.

We should use this header in all our files.


Index: F-30CE3B42F628E6E185661335E4018306.lisp
===================================================================
RCS file: /cvsroot/gennf/gennf/F-30CE3B42F628E6E185661335E4018306.lisp,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** F-30CE3B42F628E6E185661335E4018306.lisp	1 Dec 2005 16:46:42 -0000	1.1
--- F-30CE3B42F628E6E185661335E4018306.lisp	2 Dec 2005 11:11:40 -0000	1.2
***************
*** 1,8 ****
  ;; Common Lisp gpgme-wrapper
- ;; Author: Hannes Mehnert, Florian Lorenz, Fabian Otto
  ;; Date: Thu Dec  1 17:26:32 MET 2005
! 
! 
! ;; This wrapper is used in our meta-cvs patch, for signinig code hunks/sets. 
  
  ;; Example FFI call
--- 1,27 ----
+ ;; Copyright 2005 Hannes Mehnert, Florian Lorenzen, Fabian Otto
+ ;;
+ ;; This file is part of gennf.
+ ;;
+ ;; gennf is free software; you can redistribute it and/or modify
+ ;; it under the terms of the GNU General Public License as published by
+ ;; the Free Software Foundation; either version 2 of the License, or
+ ;; (at your option) any later version.
+ ;;
+ ;; gennf is distributed in the hope that it will be useful,
+ ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+ ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ ;; GNU General Public License for more details.
+ ;;
+ ;; You should have received a copy of the GNU General Public License
+ ;; along with gennf; if not, write to the Free Software
+ ;; Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ;;
+ ;; $Id$
+ 
  ;; Common Lisp gpgme-wrapper
  ;; Date: Thu Dec  1 17:26:32 MET 2005
! ;;
! ;; This wrapper is used in our meta-cvs patch (gennf),
! ;; for signinig code hunks/sets. 
  
  ;; Example FFI call



From nobody at sheep.berlios.de  Fri Dec  2 12:31:53 2005
From: nobody at sheep.berlios.de (florenz)
Date: Fri, 2 Dec 2005 12:31:53 +0100
Subject: [gennf-devel] CVSROOT log_accum.pl,NONE,1.1 loginfo,1.1,1.2
Message-ID: <200512021131.jB2BVfN10535@bat.berlios.de>

Update of /cvsroot/gennf/CVSROOT
In directory sheep:/tmp/cvs-serv29517

Modified Files:
	loginfo 
Added Files:
	log_accum.pl 
Log Message:
Added log_accum script for better commit mails.


--- NEW FILE: log_accum.pl ---
eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}' && eval 'exec perl -S $0 $argv:q'
        if 0;
#!/usr/bin/perl
# $Id: log_accum.pl,v 1.1 2005/12/02 11:31:37 florenz Exp $
#
# Perl filter to handle the log messages from the checkin of files in
# a directory.  This script will group the lists of files by log
# message, and mail a single consolidated log message at the end of
# the commit.
#
# This file assumes a pre-commit checking program that leaves the
# names of the first and last commit directories in a temporary file.
#
# Originally by David Hampton <hampton at cisco.com>
#
# Extensively hacked for FreeBSD by Peter Wemm <peter at dialix.com.au>,
#  with parts stolen from Greg Woods <woods at most.wierd.com> version.
#
# Small modification for ZEDV Physik FU-Berlin by Tobias Burnus <burnus at net-b.de>

require 5.003;		# might work with older perl5

use Sys::Hostname;	# get hostname() function

# Debug email:
my $debugemail="tburnus";
# Sendmail path
my $sendmail="/usr/sbin/sendmail";

############################################################
#
# Configurable options
#
############################################################
#
# Where do you want the RCS ID and delta info?
# 0 = none,
# 1 = in mail only,
# 2 = rcsids in both mail and logs.
#
$rcsidinfo = 2;

# Debug level, 0 = off
$debug = 0;
############################################################
#
# Constants
#
############################################################
$STATE_NONE    = 0;
$STATE_CHANGED = 1;
$STATE_ADDED   = 2;
$STATE_REMOVED = 3;
$STATE_LOG     = 4;

$FILE_PREFIX   = "#cvs.files";
$LAST_FILE     = "/tmp/#cvs.files.lastdir";
$CHANGED_FILE  = "/tmp/#cvs.files.changed";
$ADDED_FILE    = "/tmp/#cvs.files.added";
$REMOVED_FILE  = "/tmp/#cvs.files.removed";
$LOG_FILE      = "/tmp/#cvs.files.log";
$SUMMARY_FILE  = "/tmp/#cvs.files.summary";
$MAIL_FILE     = "/tmp/#cvs.files.mail";
$SUBJ_FILE     = "/tmp/#cvs.files.subj";

$CVSROOT       = "$ENV{'CVSROOT'}";

############################################################
#
# Subroutines
#
############################################################

sub cleanup_tmpfiles {
    local($wd, @files);

    $wd = `pwd`;
    chdir("/tmp");
    opendir(DIR, ".");
    push(@files, grep(/^$FILE_PREFIX\..*$id$/, readdir(DIR)));
    closedir(DIR);
    foreach (@files) {
	unlink $_;
    }
    chdir($wd);
}

sub append_to_logfile {
    local($filename, @files) = @_;

    open(FILE, ">>$filename") || die ("Cannot open for append file $filename.\n");
    print(FILE join("\n", @lines), "\n");
    close(FILE);
}

sub append_line {
    local($filename, $line) = @_;
    open(FILE, ">>$filename") || die("Cannot open for append file $filename.\n");
    print(FILE $line, "\n");
    close(FILE);
}

sub read_line {
    local($line);
    local($filename) = @_;
    open(FILE, "<$filename") || die("Cannot open for read file $filename.\n");
    $line = <FILE>;
    close(FILE);
    chop($line);
    $line;
}

sub read_logfile {
    local(@text);
    local($filename, $leader) = @_;
    open(FILE, "<$filename");
    while (<FILE>) {
	chop;
	push(@text, $leader.$_);
    }
    close(FILE);
    @text;
}

sub write_logfile {
    local($filename, @lines) = @_;

    open(FILE, ">$filename") || die("Cannot open for write log file $filename.\n");
    print FILE join("\n", @lines), "\n";
    close(FILE);
}

sub format_names {
    local($dir, @files) = @_;
    local(@lines, $indent);

    $indent = length($dir);
    if ($indent < 20) {
      $indent = 20;
    }

    $format = "    %-" . sprintf("%d", $indent) . "s ";

    $lines[0] = sprintf($format, $dir);

    if ($debug) {
	print STDERR "format_names(): dir = ", $dir, "; tag = ", $tag, "; files = ", join(":", @files), ".\n";
    }
    foreach $file (@files) {
	if (length($lines[$#lines]) + length($file) > 66) {
	    $lines[++$#lines] = sprintf($format, "", "");
	}
	$lines[$#lines] .= $file . " ";
    }

    @lines;
}

sub format_lists {
    local($header, @lines) = @_;
    local(@text, @files, $lastdir, $lastsep, $tag);

    if ($debug) {
	print STDERR "format_lists(): ", join(":", @lines), "\n";
    }
    @text = ();
    @files = ();

    $lastdir = '';
    $lastsep = '';
    foreach $line (@lines) {
	if ($line =~ /.*\/$/) {
	    if ($lastdir ne '') {
	        push(@text, &format_names($lastdir, @files));
	    }
	    $lastdir = $line;
	    $lastdir =~ s,/$,,;
	    $tag = "";	# next thing is a tag
	    @files = ();
	} elsif ($tag eq '') {
	    $tag = $line;
	    next if ($header . $tag eq $lastsep);
	    $lastsep = $header . $tag;
	    if ($tag eq 'HEAD') {
		push(@text, "  $header files:");
	    } else {
		push(@text, sprintf("  %-22s (Branch: %s)", "$header files:",
			$tag));
	    }
	} else {
	    push(@files, $line);
	}
    }
    push(@text, &format_names($lastdir, @files));

    @text;
}

sub append_names_to_file {
    local($filename, $dir, $tag, @files) = @_;

    if (@files) {
	open(FILE, ">>$filename") || die("Cannot open for append file $filename.\n");
	print FILE $dir, "\n";
	print FILE $tag, "\n";
	print FILE join("\n", @files), "\n";
	close(FILE);
    }
}

#
# do an 'cvs -Qn status' on each file in the arguments, and extract info.
#

sub change_summary_changed {
    local($out, $tag, @filenames) = @_;
    local(@revline);
    local($file, $rev, $rcsfile, $line);

    while (@filenames) {
	$file = shift @filenames;

	if ("$file" eq "") {
	    next;
	}

	open(RCS, "-|") || exec 'cvs', '-Qn', 'status', $file;

	$rev = "";
	$delta = "";
	$rcsfile = "";


	while (<RCS>) {
	    if (/^[ \t]*Repository revision/) {
		chop;
		@revline = split(' ', $_);
		$rev = $revline[2];
		$rcsfile = $revline[3];
		$rcsfile =~ s,^$CVSROOT/,,;
		$rcsfile =~ s/,v$//;
	    }
	}
	close(RCS);

	if ($rev ne '' && $rcsfile ne '') {
	    open(RCS, "-|") || exec 'cvs', '-Qn', 'log', "-r$rev", $file;
	    while (<RCS>) {
		if (/^date:/) {
		    chop;
		    $delta = $_;
		    $delta =~ s/^.*;//;
		    $delta =~ s/^[\s]+lines://;
		}
	    }
	    close(RCS);
	}

	&append_line($out, sprintf("%-9s%-12s%s", $rev, $delta, $rcsfile));
    }
}

# Write these one day.
sub change_summary_added {
}
sub change_summary_removed {
}

sub build_header {
    local($header, $datestr);
    delete $ENV{'TZ'};

    $datestr = `/bin/date +"%Y/%m/%d %H:%M:%S %Z"`;
    chop($datestr);
    $header = sprintf("%-8s    %s", $login, $datestr);
}

# !!! Mailing-list and history file mappings here !!!
if (0){
sub mlist_map {
    local($dir) = @_;		# perl warns about this....
   
    return 'cvs-CVSROOT'      if($dir =~ /^CVSROOT\//);
    return 'cvs-ports'        if($dir =~ /^ports\//);
    return 'cvs-www'          if($dir =~ /^www\//);
    return 'cvs-doc'          if($dir =~ /^doc\//);
    return 'cvs-distrib'      if($dir =~ /^distrib\//);

    return 'cvs-other'        unless($dir =~ /^src\//);

    $dir =~ s,^src/,,;

    return 'cvs-bin'          if($dir =~ /^bin\//);
    return 'cvs-contrib'      if($dir =~ /^contrib\//);
    return 'cvs-eBones'       if($dir =~ /^eBones\//);
    return 'cvs-etc'          if($dir =~ /^etc\//);
    return 'cvs-games'        if($dir =~ /^games\//);
    return 'cvs-gnu'          if($dir =~ /^gnu\//);
    return 'cvs-include'      if($dir =~ /^include\//);
    return 'cvs-kerberosIV'   if($dir =~ /^kerberosIV\//);
    return 'cvs-lib'          if($dir =~ /^lib\//);
    return 'cvs-libexec'      if($dir =~ /^libexec\//);
    return 'cvs-lkm'          if($dir =~ /^lkm\//);
    return 'cvs-release'      if($dir =~ /^release\//);
    return 'cvs-sbin'         if($dir =~ /^sbin\//);
    return 'cvs-share'        if($dir =~ /^share\//);
    return 'cvs-sys'          if($dir =~ /^sys\//);
    return 'cvs-tools'        if($dir =~ /^tools\//);
    return 'cvs-usrbin'       if($dir =~ /^usr\.bin\//);
    return 'cvs-usrsbin'      if($dir =~ /^usr\.sbin\//);

    return 'cvs-user';
}    
}

sub mlist_map {
    local($dir) = @_;		# perl warns about this....
    return undef;
}

sub do_changes_file {
    local($changes,$category, at mailaddrs);
    local(@text) = @_;
    local(%unique);

    %unique = ();
    @mailaddrs = &read_logfile("$MAIL_FILE.$id", "");
    foreach $category (@mailaddrs) {
	next if ($unique{$category});
	$unique{$category} = 1;
	if ($category =~ /^cvs-/) {
	    # convert mailing list name back to category
	    $category =~ s,\n,,;
	    $category =~ s/^cvs-//;
	    $changes = "$CVSROOT/CVSROOT/commitlogs/$category";

	    open(CHANGES, ">>$changes") || die("Cannot open $changes.\n");
	    print(CHANGES join("\n", @text), "\n\n");
	    close(CHANGES);
	}
    }
}

sub mail_notification {
    local(@text) = @_;
    local($line, $word, $subjlines, $subjwords, @mailaddrs, $host, $dom);
    local(%unique);

#    $host = hostname();
#    if ($host =~ /\.lcse\.umn\.edu$/i) {
#	$dom = '@raid.com';
#    } else {
#	$dom = '';
#    }
    $dom = '@lists.berlios.de';

    print "Mailing the commit message...\n";

    %unique = ();

    @mailaddrs = &read_logfile("$MAIL_FILE.$id", "");

    if ($debug) { 
	open(MAIL, "| $sendmail $debugemail") || die "Fuck couldn't open mail\n";
    } else {
	open(MAIL, "| $sendmail -t") || die "Fuck couldn't open mail\n";
    }

#    print(MAIL 'To: gennf-devel' . $dom);
    print(MAIL 'To: florenz at cs.tu-berlin.de');
#    foreach $line (@mailaddrs) {
#	next if ($unique{$line});
#	$unique{$line} = 1;
#	print(MAIL ", " . $line . $dom);
#    }
    print(MAIL "\n");
#    print(MAIL "From: cvsusers\@tddft.org\n");

    $subject = 'Subject: cvs commit:';
    @subj = &read_logfile("$SUBJ_FILE.$id", "");
    $subjlines = 0;
    $subjwords = 0;	# minimum of two "words" per line
    LINE: foreach $line (@subj) {
	foreach $word (split(/ /, $line)) {
	    if ($subjwords > 2 && length($subject . " " . $word) > 75) {
		if ($subjlines > 2) {
		    $subject .= " ...";
		}
		print(MAIL $subject, "\n");
		if ($subjlines > 2) {
		    $subject = "";
		    last LINE;
		}
		$subject = "        ";		# rfc822 continuation line
		$subjwords = 0;
		$subjlines++;
	    }
	    $subject .= " " . $word;
	    $subjwords++;
	}
    }
    
    if ($subject ne "") {
	print(MAIL $subject, "\n");
    }
    print (MAIL "\n");

    print(MAIL join("\n", @text));
    close(MAIL);
}

#############################################################
#
# Main Body
#
############################################################

#
# Setup environment
#
umask (002);

#
# Initialize basic variables
#
$id = getpgrp();
$state = $STATE_NONE;
$tag = '';
$login = $ENV{'USER'} || getlogin || (getpwuid($<))[0] || sprintf("uid#%d",$<);
@files = split(' ', $ARGV[0]);
@path = split('/', $files[0]);
if ($#path == 0) {
    $dir = ".";
} else {
    $dir = join('/', @path[1..$#path]);
}
$dir = $dir . "/";

if ($debug) {
  print("ARGV  - ", join(":", @ARGV), "\n");
  print("files - ", join(":", @files), "\n");
  print("path  - ", join(":", @path), "\n");
  print("dir   - ", $dir, "\n");
  print("id    - ", $id, "\n");
}

&append_line("$MAIL_FILE.$id", &mlist_map($files[0] . "/"));
&append_line("$SUBJ_FILE.$id", $ARGV[0]);

#
# Check for a new directory first.  This will always appear as a
# single item in the argument list, and an empty log message.
#
if ($ARGV[0] =~ /New directory/) {
    $header = &build_header();
    @text = ();
    push(@text, $header);
    push(@text, "");
    push(@text, "  ".$ARGV[0]);
    &do_changes_file(@text);
    #&mail_notification(@text);
    &cleanup_tmpfiles();
    exit 0;
}

#
# Check for an import command.  This will always appear as a
# single item in the argument list, and a log message.
#
if ($ARGV[0] =~ /Imported sources/) {
    $header = &build_header();

    @text = ();
    push(@text, $header);
    push(@text, "");

    push(@text, "  ".$ARGV[0]);
    &do_changes_file(@text);

    while (<STDIN>) {
	chop;                   # Drop the newline
	push(@text, "  ".$_);
    }

    &mail_notification(@text);
    &cleanup_tmpfiles();
    exit 0;
}    

#
# Iterate over the body of the message collecting information.
#
$tag = "HEAD";
while (<STDIN>) {
    s/[ \t\n]+$//;		# delete trailing space
    if (/^Revision\/Branch:/) {
	s,^Revision/Branch:,,;
	$tag = $_;
	next;
    }
    if (/^[ \t]+Tag:/) {
	s,^[ \t]+Tag: ,,;
	$tag = $_;
	next;
    }
    if (/^[ \t]+No tag$/) {
	$tag = "HEAD";
	next;
    }
    if (/^Modified Files/) { $state = $STATE_CHANGED; next; }
    if (/^Added Files/)    { $state = $STATE_ADDED;   next; }
    if (/^Removed Files/)  { $state = $STATE_REMOVED; next; }
    if (/^Log Message/)    { $state = $STATE_LOG;     next; }
    
    push (@{ $changed_files{$tag} }, split) if ($state == $STATE_CHANGED);
    push (@{ $added_files{$tag} },   split) if ($state == $STATE_ADDED);
    push (@{ $removed_files{$tag} }, split) if ($state == $STATE_REMOVED);
    if ($state == $STATE_LOG) {
	if (/^PR:$/i ||
	    /^Reviewed by:$/i ||
	    /^Submitted by:$/i ||
	    /^Obtained from:$/i) {
	    next;
	}
	push (@log_lines,     $_);
    }
}

#
# Strip leading and trailing blank lines from the log message.  Also
# compress multiple blank lines in the body of the message down to a
# single blank line.
# (Note, this only does the mail and changes log, not the rcs log).
#
while ($#log_lines > -1) {
    last if ($log_lines[0] ne "");
    shift(@log_lines);
}
while ($#log_lines > -1) {
    last if ($log_lines[$#log_lines] ne "");
    pop(@log_lines);
}
for ($l = $#log_lines; $l > 0; $l--) {
    if (($log_lines[$l - 1] eq "") && ($log_lines[$l] eq "")) {
	splice(@log_lines, $l, 1);
    }
}

#
# Find the log file that matches this log message
#
for ($i = 0; ; $i++) {
    last if (! -e "$LOG_FILE.$i.$id");
    @text = &read_logfile("$LOG_FILE.$i.$id", "");
    last if ($#text == -1);
    last if (join(" ", @log_lines) eq join(" ", @text));
}

#
# Spit out the information gathered in this pass.
#
foreach $tag ( keys %added_files ) {
    &append_names_to_file("$ADDED_FILE.$i.$id",   $dir, $tag,
	@{ $added_files{$tag} });
}
foreach $tag ( keys %changed_files ) {
    &append_names_to_file("$CHANGED_FILE.$i.$id", $dir, $tag,
	@{ $changed_files{$tag} });
}
foreach $tag ( keys %removed_files ) {
    &append_names_to_file("$REMOVED_FILE.$i.$id", $dir, $tag,
	@{ $removed_files{$tag} });
}
&write_logfile("$LOG_FILE.$i.$id", @log_lines);

if ($rcsidinfo) {
    foreach $tag ( keys %added_files ) {
	&change_summary_added("$SUMMARY_FILE.$i.$id", $tag,
	    @{ $added_files{$tag} });
    }
    foreach $tag ( keys %changed_files ) {
	&change_summary_changed("$SUMMARY_FILE.$i.$id", $tag,
	    @{ $changed_files{$tag} });
    }
    foreach $tag ( keys %removed_files ) {
	&change_summary_removed("$SUMMARY_FILE.$i.$id", $tag,
	    @{ $removed_files{$tag} });
    }
}

#
# Check whether this is the last directory.  If not, quit.
#
if (-e "$LAST_FILE.$id") {
   $_ = &read_line("$LAST_FILE.$id");
   $tmpfiles=$files[0];
   $tmpfiles =~ s,([^a-zA-Z0-9_/]),\\$1,g;
   if (! grep(/$tmpfiles$/, $_)) {
	print "More commits to come...\n";
	exit 0
   }
}

#
# This is it.  The commits are all finished.  Lump everything together
# into a single message, fire a copy off to the mailing list, and drop
# it on the end of the Changes file.
#
$header = &build_header();

#
# Produce the final compilation of the log messages
#
@text = ();
push(@text, $header);
push(@text, "");
for ($i = 0; ; $i++) {
    last if (! -e "$LOG_FILE.$i.$id");
    @lines = &read_logfile("$CHANGED_FILE.$i.$id", "");
    if ($#lines >= 0) {
	push(@text, &format_lists("Modified", @lines));
    }
    @lines = &read_logfile("$ADDED_FILE.$i.$id", "");
    if ($#lines >= 0) {
	push(@text, &format_lists("Added", @lines));
    }
    @lines = &read_logfile("$REMOVED_FILE.$i.$id", "");
    if ($#lines >= 0) {
	push(@text, &format_lists("Removed", @lines));
    }

    @lines = &read_logfile("$LOG_FILE.$i.$id", "  ");
    if ($#lines >= 0) {
        push(@text, "  Log:");
	push(@text, @lines);
    }
    if ($rcsidinfo == 2) {
	if (-e "$SUMMARY_FILE.$i.$id") {
	    push(@text, "  ");
	    push(@text, "  Revision  Changes    Path");
	    push(@text, &read_logfile("$SUMMARY_FILE.$i.$id", "  "));
	}
    }
    push(@text, "");
}
#
# Put the log message at the beginning of the Changes file
#
&do_changes_file(@text);

#
# Now generate the extra info for the mail message..
#
if ($rcsidinfo == 1) {
    $revhdr = 0;
    for ($i = 0; ; $i++) {
	last if (! -e "$LOG_FILE.$i.$id");
	if (-e "$SUMMARY_FILE.$i.$id") {
	    if (!$revhdr++) {
		push(@text, "Revision  Changes    Path");
	    }
	    push(@text, &read_logfile("$SUMMARY_FILE.$i.$id", ""));
	}
    }
    if ($revhdr) {
	push(@text, "");	# consistancy...
    }
}

#
# Mail out the notification.
#
&mail_notification(@text);
&cleanup_tmpfiles();
exit 0;

Index: loginfo
===================================================================
RCS file: /cvsroot/gennf/CVSROOT/loginfo,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** loginfo	7 Nov 2005 19:29:05 -0000	1.1
--- loginfo	2 Dec 2005 11:31:37 -0000	1.2
***************
*** 25,26 ****
--- 25,27 ----
  # or
  #DEFAULT (echo ""; id; echo %{sVv}; date; cat) >> $CVSROOT/CVSROOT/commitlog
+ DEFAULT $CVSROOT/CVSROOT/log_accum.pl %s



From gennf-devel at berlios.de  Fri Dec  2 12:55:13 2005
From: gennf-devel at berlios.de (gennf-devel at berlios.de)
Date: Fri, 2 Dec 2005 12:55:13 +0100
Subject: [gennf-devel] cvs commit: gennf F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex
Message-ID: <200512021155.jB2BtDKN015648@sheep.berlios.de>

florenz     2005/12/02 12:55:13 CET

  Modified files:
    .                    F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex 
  Log:
  Added "feature requests" concerning ASDF and th pre-build Lisp image.
  
  Revision  Changes    Path
  1.11      +4 -0      gennf/F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex


From florenz at cs.tu-berlin.de  Fri Dec  2 13:01:57 2005
From: florenz at cs.tu-berlin.de (Florian Lorenzen)
Date: Fri, 2 Dec 2005 13:01:57 +0100
Subject: [gennf-devel] Sorry.
Message-ID: <20051202120157.GA14242@caro.cs.tu-berlin.de>

Hallo Hannes, hallo Otto,

ich habe jetzt die commit mails eingeschaltet, wie Ihr seht. Leider bin
ich dabei erst mal mit syncmail auf die Nase gefallen, der packt diffs
mit hinein und das muss nicht sein. Sorry fuer die Riesenmail, nachdem
ich den Meta-CVS Code wieder hineingeschoben hatte.

Gruesse,

Florian
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 185 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/gennf-devel/attachments/20051202/16bef1d2/attachment.pgp>

From florenz at berlios.de  Tue Dec  6 18:21:54 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Tue, 6 Dec 2005 18:21:54 +0100
Subject: [gennf-devel] cvs commit: gennf F-DCFD91A2B9187774AFD3615DD030A174.lisp F-22C92A155BD388578902893F5FF7091C
 F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex MAP
Message-ID: <200512061721.jB6HLsXV004964@sheep.berlios.de>

florenz     2005/12/06 18:21:54 CET

  Modified files:
    .                    F-22C92A155BD388578902893F5FF7091C 
                         F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex 
                         MAP 
  Added files:
    .                    F-DCFD91A2B9187774AFD3615DD030A174.lisp 
  Log:
  A little bit Lisp practice.
  
  Revision  Changes    Path
  1.4       +1 -1      gennf/F-22C92A155BD388578902893F5FF7091C
  1.12      +12 -12    gennf/F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex
  1.11      +3 -0      gennf/MAP


From florenz at berlios.de  Fri Dec  9 18:22:20 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Fri, 9 Dec 2005 18:22:20 +0100
Subject: [gennf-devel] cvs commit: gennf F-1474E393BE5A7EE83A4D941FA7F9346D.lisp F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex
 F-DCFD91A2B9187774AFD3615DD030A174.lisp
Message-ID: <200512091722.jB9HMKLF014789@sheep.berlios.de>

florenz     2005/12/09 18:22:20 CET

  Modified files:
    .                    F-1474E393BE5A7EE83A4D941FA7F9346D.lisp 
                         F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex 
                         F-DCFD91A2B9187774AFD3615DD030A174.lisp 
  Log:
  The trouble with :initargs in gennf-commit.lisp are solved.
  It was just a forgotten :initarg.
  
  I have changed some definitions in the distribution model. But more
  important is that I am going to change large part of the model to a simpler
  one and want to have the current state saved somewhere.
  
  Revision  Changes    Path
  1.2       +1 -0      gennf/F-1474E393BE5A7EE83A4D941FA7F9346D.lisp
  1.13      +41 -36    gennf/F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex
  1.2       +46 -27    gennf/F-DCFD91A2B9187774AFD3615DD030A174.lisp


From florenz at berlios.de  Sun Dec 11 01:41:32 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Sun, 11 Dec 2005 01:41:32 +0100
Subject: [gennf-devel] cvs commit: gennf F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex
Message-ID: <200512110041.jBB0fWq1016392@sheep.berlios.de>

florenz     2005/12/11 01:41:31 CET

  Modified files:
    .                    F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex 
  Log:
  I have simplified the model for distributed repositories: links are
  not necessary, they can be realised via merges. The whole section
  about distributed repositories is rewritten and clarified. I have
  added a long example already including some thing which are not really
  specified yet.
  
  The logbook section is removed. It is superfluous -- as long
  as commit messages are taken seriously and all work in the project
  manifests in some repository change, commit messages are the logbook.
  
  Revision  Changes    Path
  1.14      +440 -131  gennf/F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex


From florenz at berlios.de  Sun Dec 11 23:59:55 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Sun, 11 Dec 2005 23:59:55 +0100
Subject: [gennf-devel] cvs commit: gennf F-08D5792C348D8350B394CA05532CBA56 F-B457DDF336218AEBF4158383BC4BB553.html
Message-ID: <200512112259.jBBMxtuv031547@sheep.berlios.de>

florenz     2005/12/11 23:59:55 CET

  Added files:
    .                    F-08D5792C348D8350B394CA05532CBA56 
                         F-B457DDF336218AEBF4158383BC4BB553.html 
  Log:
  We have a very basic webpage now. It describes the project goal (which
  was more or less taken out of the scratchpad), provides a link to our
  development documentation and leaves a note about our repository.
  
  Feel free to add an change whatever you consider necessary.
  
  I have included a Makefile to push up new versions of the pages.
  I thought about putting it into some commit-automatism but this does
  is not so easily possible because there is no Meta-CVS at berlios.
  The Makefile is very basic and will have to be improved in the future.


From florenz at berlios.de  Mon Dec 12 00:01:08 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Mon, 12 Dec 2005 00:01:08 +0100
Subject: [gennf-devel] cvs commit: gennf F-3E293DB4FDF7D70F72EC266B13D28C65.txt F-58D8930AD0215DAF4F30E752A5EF3EA1
Message-ID: <200512112301.jBBN18Pp031844@sheep.berlios.de>

florenz     2005/12/12 00:01:08 CET

  Modified files:
    .                    F-3E293DB4FDF7D70F72EC266B13D28C65.txt 
                         F-58D8930AD0215DAF4F30E752A5EF3EA1 
  Log:
  I have added a make target "publish" to push a new versions of
  the scratchpad.pdf on our webpage.
  
  Revision  Changes    Path
  1.2       +1 -1      gennf/F-3E293DB4FDF7D70F72EC266B13D28C65.txt
  1.3       +14 -1     gennf/F-58D8930AD0215DAF4F30E752A5EF3EA1


From florenz at berlios.de  Mon Dec 12 00:04:39 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Mon, 12 Dec 2005 00:04:39 +0100
Subject: [gennf-devel] cvs commit: gennf F-DCFD91A2B9187774AFD3615DD030A174.lisp
Message-ID: <200512112304.jBBN4dQB032157@sheep.berlios.de>

florenz     2005/12/12 00:04:39 CET

  Modified files:
    .                    F-DCFD91A2B9187774AFD3615DD030A174.lisp 
  Log:
  The GPL header was missing.
  
  Revision  Changes    Path
  1.3       +21 -0     gennf/F-DCFD91A2B9187774AFD3615DD030A174.lisp


From florenz at berlios.de  Mon Dec 12 00:13:27 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Mon, 12 Dec 2005 00:13:27 +0100
Subject: [gennf-devel] cvs commit: gennf F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex MAP TYPES
Message-ID: <200512112313.jBBNDRsj000541@sheep.berlios.de>

florenz     2005/12/12 00:13:27 CET

  Modified files:
    .                    F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex 
                         MAP TYPES 
  Log:
  I forgot to commit the directory for the webpage.
  
  I don't know why all these Lisp files come along, too...
  
  Revision  Changes    Path
  1.15      +1 -1      gennf/F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex
  1.12      +3 -0      gennf/MAP
  1.4       +1 -0      gennf/TYPES


From florenz at berlios.de  Mon Dec 12 17:05:08 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Mon, 12 Dec 2005 17:05:08 +0100
Subject: [gennf-devel] cvs commit: gennf F-B457DDF336218AEBF4158383BC4BB553.html
Message-ID: <200512121605.jBCG580D029351@sheep.berlios.de>

florenz     2005/12/12 17:05:07 CET

  Modified files:
    .                    F-B457DDF336218AEBF4158383BC4BB553.html 
  Log:
  I have added information on how to check out our code from our
  repository to the webpage using cvs to authenticate and Meta-CVS to checkout.
  
  Revision  Changes    Path
  1.2       +23 -3     gennf/F-B457DDF336218AEBF4158383BC4BB553.html


From florenz at berlios.de  Mon Dec 12 23:44:55 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Mon, 12 Dec 2005 23:44:55 +0100
Subject: [gennf-devel] cvs commit: gennf F-58D8930AD0215DAF4F30E752A5EF3EA1 F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex
Message-ID: <200512122244.jBCMitHm029357@sheep.berlios.de>

florenz     2005/12/12 23:44:55 CET

  Modified files:
    .                    F-58D8930AD0215DAF4F30E752A5EF3EA1 
                         F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex 
  Log:
  I have written a section on how to store branches.
  
  I have removed many ambiguities concerning the handling of
  branches, merges and so forth (and probably introduced lots
  of new ones).
  
  Some outdated sections were wiped out.
  
  Revision  Changes    Path
  1.4       +0 -3      gennf/F-58D8930AD0215DAF4F30E752A5EF3EA1
  1.16      +314 -189  gennf/F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex


From florenz at berlios.de  Mon Dec 12 23:49:07 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Mon, 12 Dec 2005 23:49:07 +0100
Subject: [gennf-devel] cvs commit: gennf F-58D8930AD0215DAF4F30E752A5EF3EA1
Message-ID: <200512122249.jBCMn7qd029844@sheep.berlios.de>

florenz     2005/12/12 23:49:07 CET

  Modified files:
    .                    F-58D8930AD0215DAF4F30E752A5EF3EA1 
  Log:
  There was a stupid error in the Makefile for the documents.
  
  Revision  Changes    Path
  1.5       +1 -1      gennf/F-58D8930AD0215DAF4F30E752A5EF3EA1


From florenz at berlios.de  Tue Dec 13 16:57:35 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Tue, 13 Dec 2005 16:57:35 +0100
Subject: [gennf-devel] cvs commit: gennf F-B457DDF336218AEBF4158383BC4BB553.html F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex
Message-ID: <200512131557.jBDFvZIJ025634@sheep.berlios.de>

florenz     2005/12/13 16:57:35 CET

  Modified files:
    .                    F-B457DDF336218AEBF4158383BC4BB553.html 
                         F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex 
  Log:
  The origin field of merge no has no a duplication flag to
  indicate whether the histories of the merge's branch and
  the merged-in commit are equal. This duplication
  flag should be renamed to replication (because we know of the
  duplicate).
  
  There is another nomenclatura issue: What is called commit at
  the moment should be called change and vice versa.
  
  Revision  Changes    Path
  1.3       +3 -3      gennf/F-B457DDF336218AEBF4158383BC4BB553.html
  1.17      +66 -20    gennf/F-BB223D44B63BE9E1F84D89EE7FDDFB69.tex


From florenz at cs.tu-berlin.de  Wed Dec 14 13:03:18 2005
From: florenz at cs.tu-berlin.de (Florian Lorenzen)
Date: Wed, 14 Dec 2005 13:03:18 +0100
Subject: [gennf-devel] Re: sbcl
Message-ID: <20051214120318.GA1613@fiesta.cs.tu-berlin.de>

Hallo Otto, hallo Hannes,

um Hannes auf den neuesten Stand zu bringen: Otto und ich haben gestern
eine laengere Diskussion gehabt, welche Common Lisp Implementierung wir
nun tatsaechlich fur unser Projekt nutzen. Urspruenglich wollten wir
einfach CLISP weiternutzen. Dagegen spricht allerdings, dass das FFI von
CLISP nicht so komfortabel ist. SBCL ist einfacher zu handhaben.
Weiterhin bringt SBCL ASDF einfach mit, weil es naemlich von einem er
SBCL-Entwickler stammt -- urspruenglich um contrib-packages einfach zu
laden. Weiterhin hat SBCL Unterstuetzung, um ausfuehrbare Dateien zu
erzeugen. Dazu spaeter mehr.

Mein Vorschlag war, einfach zu sagen, wir nehmen SBCL, da das Einbinden
der GPG-Bibliothek damit einfacher ist. Alle anderen
Betriebssystemfunktionen, die wir benoetigen, sollten entweder ueber
sb-posix verfuegbar sein oder muessten auch ueber das FFI eingebunden
werden.
Weiterhin wird Meta-CVS, so wies es jetzt ist, einfach mal auf ASDF und
SBCL umgestellt. Das kann dann als erster Patch auf die Sourcen schonmal
als "abgearbeitet" angesehen werden. Dazu sollte natuerlich noch eine
vernuenftige Build- und Install-Umgebung kommen (mglw. asdf-install).
Ich voluntiere, diese Umstellung zu machen, mglw. heute, aber auf jeden
Fall in den naechsten Tagen.

Nun zum Thema Executables mit SBCL: Ich habe mir das einmal angesehen
und es ist im wesentlichen die Funktion sb-executable:make-executable,
die zu verwenden ist. Diese Funktion nimmt FASL-Dateien, konkateniert
sie und schreibt sie in ein Shell-Skript. Der erste Befehl im
Shell-Skript ist ein SBCL-Aufruf, der den FASL-Code aus dem Shell-Skript
laedt und dann ausfuehrt. Beispiel:

Das Programm sieht so aus:

;; hello-world.lisp
(defun hello-world ()
  (write-line "Hello world!"))

(hello-world)

Das Executable wird so erzeugt:

REPL> (compile-file "hello-world")
REPL> (require :sb-executable)
REPL> (sb-executable:make-executable "hello" "hello-world")
REPL> (quit)

Und sieht dann so aus:

$ cat hello

#!/bin/sh --
exec sbcl --noinform --disable-debugger --userinit /dev/null --sysinit
/dev/null
 --eval "(with-open-file (i \"$0\" :element-type '(unsigned-byte 8))
(loop while
 (< ret 2) when (= (read-byte i) 10) count 1 into ret) (load i) (funcall
(quote 
VALUES)) (quit))" --end-toplevel-options ${1+"$@"}
# FASL
  compiled from "hello-world.lisp"
  at Wednesday, December 14, 2005 12:29:33 PM [-1]
  on guillaume.ossa6.net
  using SBCL version 0.9.6
?^C^@^@^@X86<^@^@^@*^@^@^@(:SB-PACKAGE-LOCKS :SB-THREAD
:SB-UNICODE)?>^@^@^@^@$E
B?^LH^@^@^@e^@^@^
<...>

Ich finde, das ganze ist ein netter Hack, aber nicht das was wir
wollen, denn:

* Wir brauchen trotzdem ein Shell-Skript, da kann man auch gleich
  einen Wrapper nehmen.
* Das laden von FASLs ist wesentlich aufwendiger als das Laden eines
  Images und nachfolgendes Aufrufen einer main-artigen Funktion
  (was daran liegt, dass FASLs Initialisierungscode enthalten koennen,
  der bei einem Image schon ausgefuehrt wurde, siehe letztes Kapitel im
  Seibel).
* Diese Executables haben dasselbe Problem wie Images: Sie sind ganz
  von der Version der CL-Implementierung abhaengig (was man nur umgehen
  koennte, wenn man ELF-Code erzeugen wurde, was GCL wohl ueber den Umweg
  C tut. GCL will ich aber nicht benutzen.)

Also, ich denke wir bleiben bei den Images, nehmen SBCL und ASDF und gut
ist. Eure Einschaetzungen wuerden mich interessieren.

Gruesse,

Florian
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 185 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/gennf-devel/attachments/20051214/74393e1d/attachment.pgp>

From hannes at mehnert.org  Thu Dec 15 01:53:34 2005
From: hannes at mehnert.org (Hannes Mehnert)
Date: Thu, 15 Dec 2005 01:53:34 +0100
Subject: [gennf-devel] Re: sbcl
In-Reply-To: <20051214120318.GA1613@fiesta.cs.tu-berlin.de>
References: <20051214120318.GA1613@fiesta.cs.tu-berlin.de>
Message-ID: <43A0BE8E.2080302@mehnert.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hallo,

habe leider gerade recht wenig Zeit, wird sich vermutlich vor Sylvester
auch nicht aendern. Ich bin damit einverstanden, SBCL zu benutzen, ist
auch der Compiler, der mir empfohlen wurde (aufgeraeumtes CMUCL).

Auch asdf finde ich eine sinnvolle Abstraktion, wenn du das umstellst
waere ich dir dankbar.



Florian Lorenzen wrote:
| [...]
| Also, ich denke wir bleiben bei den Images, nehmen SBCL und ASDF und gut
| ist. Eure Einschaetzungen wuerden mich interessieren.

Ja, bin ich dafuer.


Bis spaeter,

Hannes
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.0 (FreeBSD)
Comment: Using GnuPG with Thunderbird - http://enigmail.mozdev.org

iD8DBQFDoL6NRcuNlziBjRwRAlUqAJ4/aHcdzxlJ9dmeuJ9QVBb+7aemRQCeK9rX
wYSqjSppEA27YxKseycfIJs=
=8aTN
-----END PGP SIGNATURE-----


From florenz at berlios.de  Fri Dec 16 15:30:12 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Fri, 16 Dec 2005 15:30:12 +0100
Subject: [gennf-devel] cvs commit: CVSROOT loginfo
Message-ID: <200512161430.jBGEUCU5007029@sheep.berlios.de>

florenz     2005/12/16 15:30:11 CET

  Modified files:
    .                    loginfo 
  Log:
  Restricted commit mails to checkins in the gennf module.
  
  Revision  Changes    Path
  1.3       +1 -1      CVSROOT/loginfo


From florenz at berlios.de  Sun Dec 18 13:52:09 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Sun, 18 Dec 2005 13:52:09 +0100
Subject: [gennf-devel] cvs commit: gennf F-B457DDF336218AEBF4158383BC4BB553.html
Message-ID: <200512181252.jBICq9N5031116@sheep.berlios.de>

florenz     2005/12/18 13:52:08 CET

  Modified files:
    .                    F-B457DDF336218AEBF4158383BC4BB553.html 
  Log:
  The web page is successfully checked by the W3C validators.
  
  Revision  Changes    Path
  1.5       +43 -24    gennf/F-B457DDF336218AEBF4158383BC4BB553.html


From florenz at berlios.de  Tue Dec 27 18:28:24 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Tue, 27 Dec 2005 18:28:24 +0100
Subject: [gennf-devel] cvs commit: gennf F-DBEF23F4E5EC75C4CF994FA5C7DE0326.lisp
Message-ID: <200512271728.jBRHSOhF021693@sheep.berlios.de>

florenz     2005/12/27 18:28:24 CET

  Added files:
    .                    F-DBEF23F4E5EC75C4CF994FA5C7DE0326.lisp 
  Log:
  The new file sbcl-unix.lisp is a replacement for clisp-unix.lisp and
  cmucl-unix.lisp to use Meta-CVS with SBCL. It is not tested yet. It will
  not work at the moment because the build-system still has to be modified.
  But I wanted to have this state checked in anyway.
  
  There also have to be some changes done to dirwalk.lisp because
  there are no dir-handles in the Unix glue code anymore.
  
  The new file sbcl-unix.lisp used mostly portable code but some
  parts are SBCL-specific. It needs osicat in a patched version which
  is in our MCVS (module osicat-patch) and port-path which is a tiny
  library based in Peter Seibel's pathnames with smaller functionality
  and some extra macros an functions (also in our MCVS, module port-path).
  I am sure this will be extended in the next weeks.


From florenz at berlios.de  Wed Dec 28 17:03:02 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Wed, 28 Dec 2005 17:03:02 +0100
Subject: [gennf-devel] cvs commit: port-path F-7A7785FBE6038B4802ADCD8577015F59.lisp F-E4E8137ED6A2987D581A8AB6A46FB7DA.lisp
Message-ID: <200512281603.jBSG32v6010870@sheep.berlios.de>

florenz     2005/12/28 17:03:02 CET

  Modified files:
    .                    F-7A7785FBE6038B4802ADCD8577015F59.lisp 
                         F-E4E8137ED6A2987D581A8AB6A46FB7DA.lisp 
  Log:
  The function directory-listing from Peter's book has been added.
  
  Revision  Changes    Path
  1.2       +51 -2     port-path/F-7A7785FBE6038B4802ADCD8577015F59.lisp
  1.2       +3 -2      port-path/F-E4E8137ED6A2987D581A8AB6A46FB7DA.lisp


From florenz at berlios.de  Wed Dec 28 17:01:58 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Wed, 28 Dec 2005 17:01:58 +0100
Subject: [gennf-devel] cvs commit: osicat-patch F-72B2A1190FD51FF00A6BD408F46F482C.lisp F-C5BC257C99D9996303F43B466FBDB6FD.lisp
 F-E6058D7D82D4A1E1C26BE04A5FBC5362.c F-F3740194C5A9CE17405901A0C86194A3.lisp
Message-ID: <200512281601.jBSG1wHU010674@sheep.berlios.de>

florenz     2005/12/28 17:01:58 CET

  Modified files:
    .                    F-72B2A1190FD51FF00A6BD408F46F482C.lisp 
                         F-C5BC257C99D9996303F43B466FBDB6FD.lisp 
                         F-E6058D7D82D4A1E1C26BE04A5FBC5362.c 
                         F-F3740194C5A9CE17405901A0C86194A3.lisp 
  Log:
  Bugfix: follow-p was not handled correct in many cases.
  
  Functions to query the last Unix error and the process' terminal
  are added because Meta-CVS wants them.
  
  Revision  Changes    Path
  1.2       +10 -2     osicat-patch/F-72B2A1190FD51FF00A6BD408F46F482C.lisp
  1.2       +14 -2     osicat-patch/F-C5BC257C99D9996303F43B466FBDB6FD.lisp
  1.2       +47 -4     osicat-patch/F-E6058D7D82D4A1E1C26BE04A5FBC5362.c
  1.2       +67 -8     osicat-patch/F-F3740194C5A9CE17405901A0C86194A3.lisp


From florenz at berlios.de  Wed Dec 28 17:20:41 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Wed, 28 Dec 2005 17:20:41 +0100
Subject: [gennf-devel] cvs commit: gennf F-01BFC84C7B5AA5916B1FC95B481B0DEC.lisp F-1474E393BE5A7EE83A4D941FA7F9346D.lisp
 F-14CAFC7D376F98290437724D067E63D4.lisp F-1923CF213AD21CBF66474E7C068BFECD.lisp F-21E77680CDA9B7DA5133627E47FA0987.lisp
 F-24AFFF4D581EFC1C6EF802B4AAB5D27B.lisp F-32A3BA955BE6E0F48ABEDF5C42137D5E.lisp F-389E31FE3917AE1504A5DED502AE3D51.lisp
 F-3C5788EDE4B0D9B8845BDDF41278246B.lisp F-3CDB81902ABA8CED95DEEBDA8590315E.lisp F-40CE98E89C297E85E8209004EE49D372.lisp ...
Message-ID: <200512281620.jBSGKfrg012947@sheep.berlios.de>

florenz     2005/12/28 17:20:41 CET

  Modified files:
    .                    F-01BFC84C7B5AA5916B1FC95B481B0DEC.lisp 
                         F-1474E393BE5A7EE83A4D941FA7F9346D.lisp 
                         F-14CAFC7D376F98290437724D067E63D4.lisp 
                         F-1923CF213AD21CBF66474E7C068BFECD.lisp 
                         F-21E77680CDA9B7DA5133627E47FA0987.lisp 
                         F-24AFFF4D581EFC1C6EF802B4AAB5D27B.lisp 
                         F-32A3BA955BE6E0F48ABEDF5C42137D5E.lisp 
                         F-389E31FE3917AE1504A5DED502AE3D51.lisp 
                         F-3C5788EDE4B0D9B8845BDDF41278246B.lisp 
                         F-3CDB81902ABA8CED95DEEBDA8590315E.lisp 
                         F-40CE98E89C297E85E8209004EE49D372.lisp 
                         F-418A4A44531B20FCEB6851D533A75A04.lisp 
                         F-4F2D9B26F5FB9FA0F66EBB82BE7E8EF1.lisp 
                         F-4F34E424D04A8DF9D18E24CFE19D425C.lisp 
                         F-54A44C0786853024F450D715BBB3997E.lisp 
                         F-5B815906BE2D64E9BC2E48B76242BFF2.lisp 
                         F-6763C87866B0E9BE56C154839D6FAB55.lisp 
                         F-6C2D433380C1B1B204522582A4F30484.lisp 
                         F-74915F0862B511AC9C233FDCB87DBEF8.lisp 
                         F-7849808E8711BA9FBEB0917F33B12A79.lisp 
                         F-8E73F07FB339A6981C69AF06C278B49A.lisp 
                         F-97770D7ED2DFF388BC60EAB380950A77.lisp 
                         F-9FD71CEB3A8045B747F54A629ED92A8D.lisp 
                         F-A30F4DBDE92A478CEB73EF64056E4340.lisp 
                         F-A3262E4C63ABCB9396F1C019B9CAE540.lisp 
                         F-A371BDB8A9CF854FE00C63C1264B1D99.lisp 
                         F-A580617EC4FE7BAAC13B25642EF48CAC.lisp 
                         F-B457DDF336218AEBF4158383BC4BB553.html 
                         F-C25BFAA9CFD16915F31BF90D03646B52.lisp 
                         F-CA4E16937768388DD32FAD6ADA8B6A2F.lisp 
                         F-D3884C19BD6F4028992C7EE4A564DCA3.lisp 
                         F-D3DC1953503E35C4D11154495DE074FB.lisp 
                         F-DBEF23F4E5EC75C4CF994FA5C7DE0326.lisp 
                         F-DDFDB88C633DE12D1C1F5B3C3312FC20.lisp 
                         F-E3131BB19D8294EBDA5E9BFD1C50BB5D.lisp 
                         F-E8B8309E1270A0D1EDB0FB64AB2298D2.lisp 
                         F-E9DFED59ECE7621E4773E6B51E9D2881.lisp 
                         F-F3CA06292A3D8237E960CB2844A8D5C0.lisp 
                         F-FABFD2A24671001E7FA5E630FED91059.lisp 
                         F-FD67F73260C22A0EC7EF43A6F702E80F.lisp 
                         MAP 
  Log:
  Meta-CVS now compiles with SBCL. But the resulting program is
  not tested yet and very likely to be awfully error prone
  (and the whole thing took much longer than expected).
  
  There is a basic ASDF definition in ASDF-INSTALL structure
  for Meta-CVS and the code can be loaded into SBCL with
  
  (asdf:operate 'asdf:load-op :gennf)
  
  provided ASDF finds gennf.asd in its search paths. The easiest way to
  do this is to link it into ~/.sbcl/systems:
  
  $ ln ~/ti/ossi/gennf/src/gennf.asd ~/.sbcl/systems/gennf.asd
  
  The patched version of osicat and port path have to be available as well.
  
  In order to get things working with ASDF all files wer put into package
  gennf. Some oddities remain in packages.lisp (see FIXME there).
  
  A build and install script is still missing. This will be the next thing
  to do. Up to now the ASDF definition is only suitable for SBCL, for CLISP
  or CMUCL (if that works at all) the old build environment has to be
  used.
  
  Revision  Changes    Path
  1.2       +11 -9     gennf/F-01BFC84C7B5AA5916B1FC95B481B0DEC.lisp
  1.3       +4 -2      gennf/F-1474E393BE5A7EE83A4D941FA7F9346D.lisp
  1.2       +5 -3      gennf/F-14CAFC7D376F98290437724D067E63D4.lisp
  1.2       +3 -1      gennf/F-1923CF213AD21CBF66474E7C068BFECD.lisp
  1.2       +5 -3      gennf/F-21E77680CDA9B7DA5133627E47FA0987.lisp
  1.2       +2 -0      gennf/F-24AFFF4D581EFC1C6EF802B4AAB5D27B.lisp
  1.2       +11 -9     gennf/F-32A3BA955BE6E0F48ABEDF5C42137D5E.lisp
  1.2       +3 -1      gennf/F-389E31FE3917AE1504A5DED502AE3D51.lisp
  1.2       +9 -7      gennf/F-3C5788EDE4B0D9B8845BDDF41278246B.lisp
  1.2       +7 -5      gennf/F-3CDB81902ABA8CED95DEEBDA8590315E.lisp
  1.2       +10 -8     gennf/F-40CE98E89C297E85E8209004EE49D372.lisp
  1.2       +11 -9     gennf/F-418A4A44531B20FCEB6851D533A75A04.lisp
  1.2       +6 -4      gennf/F-4F2D9B26F5FB9FA0F66EBB82BE7E8EF1.lisp
  1.2       +4 -2      gennf/F-4F34E424D04A8DF9D18E24CFE19D425C.lisp
  1.2       +8 -6      gennf/F-54A44C0786853024F450D715BBB3997E.lisp
  1.2       +4 -2      gennf/F-5B815906BE2D64E9BC2E48B76242BFF2.lisp
  1.2       +6 -4      gennf/F-6763C87866B0E9BE56C154839D6FAB55.lisp
  1.2       +2 -0      gennf/F-6C2D433380C1B1B204522582A4F30484.lisp
  1.2       +8 -6      gennf/F-74915F0862B511AC9C233FDCB87DBEF8.lisp
  1.2       +3 -1      gennf/F-7849808E8711BA9FBEB0917F33B12A79.lisp
  1.2       +4 -2      gennf/F-8E73F07FB339A6981C69AF06C278B49A.lisp
  1.2       +27 -17    gennf/F-97770D7ED2DFF388BC60EAB380950A77.lisp
  1.2       +8 -6      gennf/F-9FD71CEB3A8045B747F54A629ED92A8D.lisp
  1.2       +5 -3      gennf/F-A30F4DBDE92A478CEB73EF64056E4340.lisp
  1.2       +1 -1      gennf/F-A3262E4C63ABCB9396F1C019B9CAE540.lisp
  1.2       +62 -53    gennf/F-A371BDB8A9CF854FE00C63C1264B1D99.lisp
  1.2       +11 -9     gennf/F-A580617EC4FE7BAAC13B25642EF48CAC.lisp
  1.6       +2 -2      gennf/F-B457DDF336218AEBF4158383BC4BB553.html
  1.2       +7 -5      gennf/F-C25BFAA9CFD16915F31BF90D03646B52.lisp
  1.2       +30 -6     gennf/F-CA4E16937768388DD32FAD6ADA8B6A2F.lisp
  1.2       +3 -1      gennf/F-D3884C19BD6F4028992C7EE4A564DCA3.lisp
  1.2       +19 -17    gennf/F-D3DC1953503E35C4D11154495DE074FB.lisp
  1.2       +61 -4     gennf/F-DBEF23F4E5EC75C4CF994FA5C7DE0326.lisp
  1.2       +8 -6      gennf/F-DDFDB88C633DE12D1C1F5B3C3312FC20.lisp
  1.2       +6 -4      gennf/F-E3131BB19D8294EBDA5E9BFD1C50BB5D.lisp
  1.2       +17 -15    gennf/F-E8B8309E1270A0D1EDB0FB64AB2298D2.lisp
  1.2       +8 -6      gennf/F-E9DFED59ECE7621E4773E6B51E9D2881.lisp
  1.2       +9 -7      gennf/F-F3CA06292A3D8237E960CB2844A8D5C0.lisp
  1.2       +3 -1      gennf/F-FABFD2A24671001E7FA5E630FED91059.lisp
  1.2       +4 -2      gennf/F-FD67F73260C22A0EC7EF43A6F702E80F.lisp
  1.13      +3 -0      gennf/MAP


From florenz at berlios.de  Wed Dec 28 22:34:30 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Wed, 28 Dec 2005 22:34:30 +0100
Subject: [gennf-devel] cvs commit: gennf F-21E77680CDA9B7DA5133627E47FA0987.lisp F-A371BDB8A9CF854FE00C63C1264B1D99.lisp
Message-ID: <200512282134.jBSLYUOW009201@sheep.berlios.de>

florenz     2005/12/28 22:34:30 CET

  Modified files:
    .                    F-21E77680CDA9B7DA5133627E47FA0987.lisp 
                         F-A371BDB8A9CF854FE00C63C1264B1D99.lisp 
  Log:
  It is now possible to start Meta-CVS as an SBCL image.
  Currently I work on a usable Makefile.
  
  There were problems with the terminal handling. In the original
  Meta-CVS code ctermid was queried and opened as a stream. This
  causes trouble with SBCL, probably due to buffering issues.
  It is much easier to use *debug-io* as input-/output-stream
  for error handling (this way ctermid is not needed and to me
  it seems quite reasonable that Common Lisp implementation bind
  this variable to something sensible).
  
  Revision  Changes    Path
  1.3       +1 -0      gennf/F-21E77680CDA9B7DA5133627E47FA0987.lisp
  1.3       +15 -4     gennf/F-A371BDB8A9CF854FE00C63C1264B1D99.lisp


From florenz at berlios.de  Thu Dec 29 16:20:42 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Thu, 29 Dec 2005 16:20:42 +0100
Subject: [gennf-devel] cvs commit: gennf F-2019E4ADA667C5B63A025FC92E791425 F-6F5CF359180DF63FF524635A543C7BF5
 MAP
Message-ID: <200512291520.jBTFKgXL000628@sheep.berlios.de>

florenz     2005/12/29 16:20:41 CET

  Modified files:
    .                    MAP 
  Added files:
    .                    F-2019E4ADA667C5B63A025FC92E791425 
                         F-6F5CF359180DF63FF524635A543C7BF5 
  Log:
  The Makefile is able to produce an image gennf.run in the
  current directory.
  The script gennf can be used to start the Meta-CVS build.
  The script only works if sbcl is in the PATH and gennf.run
  in the current directory. This is not yet a fully fledged
  installation environemt but sufficient for developing and
  testing purposes.
  
  Revision  Changes    Path
  1.14      +8 -0      gennf/MAP


From florenz at berlios.de  Fri Dec 30 19:08:03 2005
From: florenz at berlios.de (florenz at BerliOS)
Date: Fri, 30 Dec 2005 19:08:03 +0100
Subject: [gennf-devel] cvs commit: gennf F-01BFC84C7B5AA5916B1FC95B481B0DEC.lisp F-24AFFF4D581EFC1C6EF802B4AAB5D27B.lisp
 F-DBEF23F4E5EC75C4CF994FA5C7DE0326.lisp
Message-ID: <200512301808.jBUI83J5001942@sheep.berlios.de>

florenz     2005/12/30 19:08:03 CET

  Modified files:
    .                    F-01BFC84C7B5AA5916B1FC95B481B0DEC.lisp 
                         F-24AFFF4D581EFC1C6EF802B4AAB5D27B.lisp 
                         F-DBEF23F4E5EC75C4CF994FA5C7DE0326.lisp 
  Log:
  Lots of bugfixes concerning the SBCL port. The SBCL build was successful
  used to do a
  
  $ gennf create
  
  but there remains one stupid problem:
  
  The sb-ext:run-program on Linux with SBCL v0.9.0.18 has trouble
  with in- and output for visual programs like vi. On Solaris with
  SBCL v0.8.18 it works. I suspect that it is a SBCL bug (as 0.9.0.18
  is not the newest version) but this has to be investigated. I think I
  try a newer SBCL version but 0.9.6 or something had trouble wih SLIME.
  
  Revision  Changes    Path
  1.3       +1 -1      gennf/F-01BFC84C7B5AA5916B1FC95B481B0DEC.lisp
  1.3       +2 -0      gennf/F-24AFFF4D581EFC1C6EF802B4AAB5D27B.lisp
  1.3       +24 -8     gennf/F-DBEF23F4E5EC75C4CF994FA5C7DE0326.lisp


